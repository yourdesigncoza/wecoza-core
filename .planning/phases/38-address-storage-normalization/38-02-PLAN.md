---
phase: 38-address-storage-normalization
plan: 02
type: execute
wave: 2
depends_on: ["38-01"]
files_modified:
  - src/Agents/Repositories/AgentRepository.php
  - src/Agents/Services/AgentService.php
  - src/Agents/Models/AgentModel.php
autonomous: true

must_haves:
  truths:
    - "AgentRepository reads address data from locations table via location_id FK, falling back to old columns"
    - "AgentRepository writes address data to both locations table AND old agent columns (dual-write)"
    - "Agent capture/edit forms work identically — users see no change in address workflow"
    - "AgentService form submission handles location creation/update transparently"
    - "Existing agent CRUD operations return identical data shape"
  artifacts:
    - path: "src/Agents/Repositories/AgentRepository.php"
      provides: "Dual-read and dual-write for agent addresses via locations table"
      contains: "location_id"
    - path: "src/Agents/Services/AgentService.php"
      provides: "Location creation/update during agent form submission"
      contains: "LocationsModel"
    - path: "src/Agents/Models/AgentModel.php"
      provides: "Updated defaults including location_id field"
      contains: "location_id"
  key_links:
    - from: "src/Agents/Repositories/AgentRepository.php"
      to: "public.locations"
      via: "LEFT JOIN on agents.location_id = locations.location_id"
      pattern: "LEFT JOIN.*locations.*ON.*location_id"
    - from: "src/Agents/Services/AgentService.php"
      to: "src/Clients/Models/LocationsModel.php"
      via: "LocationsModel::create() for new locations, LocationsModel::updateById() for existing"
      pattern: "LocationsModel"
    - from: "src/Agents/Repositories/AgentRepository.php"
      to: "src/Agents/Services/AgentService.php"
      via: "Service calls repository for agent CRUD, repository handles dual-write"
      pattern: "createAgent|updateAgent"
---

<objective>
Update AgentRepository, AgentService, and AgentModel to use the shared locations table for address storage with dual-read (locations table with fallback to old columns) and dual-write (both locations table and old columns).

Purpose: Enables agents to read/write addresses via the shared locations infrastructure while maintaining full backward compatibility during the transition period. Old address columns continue to be populated, ensuring no breakage.

Output: Modified repository with dual-read/dual-write, service with location management, model with location_id support.
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-address-storage-normalization/38-01-SUMMARY.md
@src/Agents/Repositories/AgentRepository.php
@src/Agents/Services/AgentService.php
@src/Agents/Models/AgentModel.php
@src/Clients/Models/LocationsModel.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update AgentModel and AgentRepository for dual-read address resolution</name>
  <files>src/Agents/Models/AgentModel.php, src/Agents/Repositories/AgentRepository.php</files>
  <action>
**AgentModel changes:**

1. Add `'location_id' => null` to the `$defaults` array (Address Information section)
2. Add `'location_id'` to `getAllowedInsertColumns()` and `getAllowedUpdateColumns()` in AgentRepository (so it passes column whitelisting)

**AgentRepository changes — Dual-Read:**

1. Update `getAgent(int $agentId)` method:
   - Change the SQL query to LEFT JOIN the locations table:
   ```sql
   SELECT a.*,
          l.street_address AS loc_street_address,
          l.suburb AS loc_suburb,
          l.town AS loc_town,
          l.province AS loc_province,
          l.postal_code AS loc_postal_code
   FROM agents a
   LEFT JOIN public.locations l ON a.location_id = l.location_id
   WHERE a.agent_id = :agent_id AND a.status != 'deleted'
   LIMIT 1
   ```
   - After fetching the row, call a new private method `resolveAddressFields(array $row): array` that:
     a. If `loc_street_address` is not null (location record exists), override the inline address fields:
        - `residential_address_line` ← `loc_street_address`
        - `residential_suburb` ← `loc_suburb`
        - `city` ← `loc_town`
        - `province` ← `loc_province`
        - `residential_postal_code` ← `loc_postal_code`
     b. Remove the `loc_*` prefixed keys from the returned array
     c. Return the resolved array
   - This provides fallback: if location_id is NULL or locations record is missing, the inline columns are used as-is

2. Update `getAgentByEmail(string $email)` and `getAgentByIdNumber(string $idNumber)` methods with the same LEFT JOIN and `resolveAddressFields()` call

3. Update `getAgents(array $args)` method:
   - Add the same LEFT JOIN to the main query
   - Apply `resolveAddressFields()` to each row in the result

4. Add `'location_id'` to `getAllowedInsertColumns()` and `getAllowedUpdateColumns()` whitelists

5. Create the private `resolveAddressFields(array $row): array` method as described above

**IMPORTANT implementation details:**
- The LEFT JOIN ensures backward compatibility: agents without location_id still return their inline address data
- The `loc_` prefix prevents column name collisions (both agents and locations have `province`)
- The `resolveAddressFields()` method is the SINGLE point of address resolution — DRY principle
- Do NOT change the return type or shape of any public method — consumers must see identical data
  </action>
  <verify>
1. `php -l src/Agents/Models/AgentModel.php` — no syntax errors
2. `php -l src/Agents/Repositories/AgentRepository.php` — no syntax errors
3. Grep for `resolveAddressFields` in AgentRepository — should appear in getAgent, getAgentByEmail, getAgentByIdNumber, getAgents, and the method definition
4. Grep for `LEFT JOIN.*locations` in AgentRepository — should appear in all read methods
5. Grep for `location_id` in AgentRepository getAllowedInsertColumns — should be present
  </verify>
  <done>
AgentRepository reads addresses from locations table via LEFT JOIN with fallback to inline columns. AgentModel includes location_id in defaults. All read methods (getAgent, getAgentByEmail, getAgentByIdNumber, getAgents) use unified resolveAddressFields() for address resolution. Column whitelists updated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update AgentService for dual-write location management</name>
  <files>src/Agents/Services/AgentService.php, src/Agents/Repositories/AgentRepository.php</files>
  <action>
**AgentService changes — Dual-Write via location management:**

1. Add `use WeCoza\Clients\Models\LocationsModel;` import at the top

2. Add a new private method `syncAddressToLocation(array $addressData, ?int $existingLocationId = null): ?int` that:
   a. Maps agent address fields to locations table fields:
      - `street_address` ← `residential_address_line` (append `, address_line_2` if not empty)
      - `suburb` ← `residential_suburb`
      - `town` ← `city`
      - `province` ← `province`
      - `postal_code` ← `residential_postal_code`
   b. If ALL address fields are empty, return null (no location to create)
   c. Instantiate `LocationsModel`
   d. If `$existingLocationId` is not null:
      - Update existing location via `$locationsModel->updateById($existingLocationId, $locationData)`
      - Return `$existingLocationId`
   e. If `$existingLocationId` is null:
      - Check for duplicate location via `$locationsModel->checkDuplicates($locationData['street_address'], $locationData['suburb'], $locationData['town'])`
      - If exact match found (street_address + suburb + town + province + postal_code all match case-insensitively), reuse that location_id
      - Otherwise create new location via `$locationsModel->create($locationData)`
      - Return the new/reused location_id
   f. On any failure, log via `wecoza_log()` and return null (graceful degradation — agent save still succeeds with inline columns)

3. Update `handleAgentFormSubmission()` method:
   - AFTER validation passes but BEFORE calling `$this->repository->createAgent()` or `$this->repository->updateAgent()`:
     a. Extract address fields from `$data`
     b. Determine existing location_id: if updating, get it from `$currentAgent['location_id'] ?? null`
     c. Call `$locationId = $this->syncAddressToLocation($data, $existingLocationId)`
     d. If `$locationId` is not null, set `$data['location_id'] = $locationId`
   - The repository's createAgent/updateAgent will then save location_id to the agents table (dual-write: address fields still go to old columns via existing sanitization, AND location_id links to normalized record)

**AgentRepository changes — Ensure dual-write works:**

1. Add `'location_id'` to the `sanitizeAgentData()` method's fields array:
   ```php
   'location_id' => 'absint',
   ```
   BUT with special handling: if the value is 0 or empty, set to null (to avoid FK violation). Add this after the main loop:
   ```php
   if (isset($cleanData['location_id']) && empty($cleanData['location_id'])) {
       $cleanData['location_id'] = null;
   }
   ```

**IMPORTANT implementation details:**
- Dual-write means: old address columns STILL get written (existing sanitizeAgentData handles this), AND location_id gets set
- Location creation uses the existing LocationsModel::create() — reuses the Clients module infrastructure
- LocationsModel::create() requires longitude/latitude but accepts NULL — pass NULL for both since agent forms don't capture coordinates
- The syncAddressToLocation method handles the LocationsModel validation requirement: it needs to pass non-null longitude/latitude. Since LocationsModel::validate() requires these, BUT we're calling create() directly (which normalizes null coords), this is fine. However, if validation is called separately, we need to set longitude=null, latitude=null explicitly.
- Graceful degradation: if location sync fails, the agent still saves with inline address columns — no data loss
- The `checkDuplicates` method on LocationsModel uses flexible LIKE matching — for exact match reuse, we need to compare all 5 fields case-insensitively after getting candidates
  </action>
  <verify>
1. `php -l src/Agents/Services/AgentService.php` — no syntax errors
2. `php -l src/Agents/Repositories/AgentRepository.php` — no syntax errors
3. Grep for `syncAddressToLocation` in AgentService — should appear in method definition and handleAgentFormSubmission
4. Grep for `LocationsModel` in AgentService — should appear in use statement and syncAddressToLocation
5. Grep for `location_id` in AgentRepository sanitizeAgentData — should be present with null handling
6. Verify the data flow: collectFormData() → validate() → syncAddressToLocation() → createAgent/updateAgent with location_id
  </verify>
  <done>
AgentService handles location creation/update during form submission via syncAddressToLocation(). Dual-write implemented: address data goes to both old inline columns AND locations table via location_id FK. LocationsModel reused from Clients module — no duplicate code. Graceful degradation on location sync failure. AgentRepository sanitization handles location_id with null coercion for empty values.
  </done>
</task>

</tasks>

<verification>
- All three PHP files pass `php -l` syntax check
- AgentRepository read methods use LEFT JOIN with fallback
- AgentRepository write methods include location_id in whitelists
- AgentService creates/updates location records during form submission
- No changes to return types or data shapes — backward compatible
- Address resolution centralized in resolveAddressFields() (DRY)
- Location sync centralized in syncAddressToLocation() (DRY)
</verification>

<success_criteria>
- Agent CRUD operations return address data from locations table (with fallback)
- Agent form submissions write to both old columns and locations table
- No breaking changes to existing consumers (controllers, AJAX handlers, views)
- LocationsModel from Clients module reused — no code duplication
</success_criteria>

<output>
After completion, create `.planning/phases/38-address-storage-normalization/38-02-SUMMARY.md`
</output>
