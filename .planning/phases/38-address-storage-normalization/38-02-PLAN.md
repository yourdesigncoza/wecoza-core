---
phase: 38-address-storage-normalization
plan: 02
type: execute
wave: 2
depends_on: ["38-01"]
files_modified:
  - src/Agents/Repositories/AgentRepository.php
  - src/Agents/Services/AgentService.php
  - src/Agents/Models/AgentModel.php
autonomous: true

must_haves:
  truths:
    - "AgentRepository reads address data from locations table via location_id FK, falling back to old columns"
    - "AgentRepository writes address data to both locations table AND old agent columns (dual-write)"
    - "Agent capture/edit forms work identically — users see no change in address workflow"
    - "AgentService form submission handles location creation/update transparently"
    - "Existing agent CRUD operations return identical data shape"
  artifacts:
    - path: "src/Agents/Repositories/AgentRepository.php"
      provides: "Dual-read and dual-write for agent addresses via locations table"
      contains: "location_id"
    - path: "src/Agents/Services/AgentService.php"
      provides: "Location creation/update during agent form submission via direct SQL"
      contains: "syncAddressToLocation"
    - path: "src/Agents/Models/AgentModel.php"
      provides: "Updated defaults including location_id field"
      contains: "location_id"
  key_links:
    - from: "src/Agents/Repositories/AgentRepository.php"
      to: "public.locations"
      via: "LEFT JOIN on agents.location_id = locations.location_id"
      pattern: "LEFT JOIN.*locations.*ON.*location_id"
    - from: "src/Agents/Services/AgentService.php"
      to: "public.locations"
      via: "Direct SQL INSERT/UPDATE via wecoza_db() — bypasses LocationsModel to avoid longitude/latitude validation"
      pattern: "wecoza_db\\(\\)->insert.*locations"
    - from: "src/Agents/Repositories/AgentRepository.php"
      to: "src/Agents/Services/AgentService.php"
      via: "Service calls repository for agent CRUD, repository handles dual-write"
      pattern: "createAgent|updateAgent"
---

<objective>
Update AgentRepository, AgentService, and AgentModel to use the shared locations table for address storage with dual-read (locations table with fallback to old columns) and dual-write (both locations table and old columns).

Purpose: Enables agents to read/write addresses via the shared locations infrastructure while maintaining full backward compatibility during the transition period. Old address columns continue to be populated, ensuring no breakage.

Output: Modified repository with dual-read/dual-write, service with location management, model with location_id support.
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-address-storage-normalization/38-01-SUMMARY.md
@src/Agents/Repositories/AgentRepository.php
@src/Agents/Services/AgentService.php
@src/Agents/Models/AgentModel.php
@src/Clients/Models/LocationsModel.php  # Read-only reference for table schema — do NOT call its methods (validate() requires non-null coords)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update AgentModel and AgentRepository for dual-read address resolution</name>
  <files>src/Agents/Models/AgentModel.php, src/Agents/Repositories/AgentRepository.php</files>
  <action>
**AgentModel changes:**

1. Add `'location_id' => null` to the `$defaults` array (Address Information section)
2. Add `'location_id'` to `getAllowedInsertColumns()` and `getAllowedUpdateColumns()` in AgentRepository (so it passes column whitelisting)

**AgentRepository changes — Dual-Read:**

1. Update `getAgent(int $agentId)` method:
   - Change the SQL query to LEFT JOIN the locations table:
   ```sql
   SELECT a.*,
          l.street_address AS loc_street_address,
          l.suburb AS loc_suburb,
          l.town AS loc_town,
          l.province AS loc_province,
          l.postal_code AS loc_postal_code
   FROM agents a
   LEFT JOIN public.locations l ON a.location_id = l.location_id
   WHERE a.agent_id = :agent_id AND a.status != 'deleted'
   LIMIT 1
   ```
   - After fetching the row, call a new private method `resolveAddressFields(array $row): array` that:
     a. If `loc_street_address` is not null (location record exists), override the inline address fields:
        - `residential_address_line` ← `loc_street_address`
        - `residential_suburb` ← `loc_suburb`
        - `city` ← `loc_town`
        - `province` ← `loc_province`
        - `residential_postal_code` ← `loc_postal_code`
        - **Note:** `address_line_2` will be empty/unchanged for location-based records because the write path concatenates address_line_2 into street_address. This is a known limitation during the dual-write period and is acceptable because the original address_line_2 value is still preserved in the agents table inline column.
     b. Remove the `loc_*` prefixed keys from the returned array
     c. Return the resolved array
   - This provides fallback: if location_id is NULL or locations record is missing, the inline columns are used as-is

2. Update `getAgentByEmail(string $email)` and `getAgentByIdNumber(string $idNumber)` methods with the same LEFT JOIN and `resolveAddressFields()` call

3. Update `getAgents(array $args)` method:
   - Add the same LEFT JOIN to the main query
   - Apply `resolveAddressFields()` to each row in the result

4. Add `'location_id'` to `getAllowedInsertColumns()` and `getAllowedUpdateColumns()` whitelists

5. Create the private `resolveAddressFields(array $row): array` method as described above

**IMPORTANT implementation details:**
- The LEFT JOIN ensures backward compatibility: agents without location_id still return their inline address data
- The `loc_` prefix prevents column name collisions (both agents and locations have `province`)
- The `resolveAddressFields()` method is the SINGLE point of address resolution — DRY principle
- Do NOT change the return type or shape of any public method — consumers must see identical data
  </action>
  <verify>
1. `php -l src/Agents/Models/AgentModel.php` — no syntax errors
2. `php -l src/Agents/Repositories/AgentRepository.php` — no syntax errors
3. Grep for `resolveAddressFields` in AgentRepository — should appear in getAgent, getAgentByEmail, getAgentByIdNumber, getAgents, and the method definition
4. Grep for `LEFT JOIN.*locations` in AgentRepository — should appear in all read methods
5. Grep for `location_id` in AgentRepository getAllowedInsertColumns — should be present
  </verify>
  <done>
AgentRepository reads addresses from locations table via LEFT JOIN with fallback to inline columns. AgentModel includes location_id in defaults. All read methods (getAgent, getAgentByEmail, getAgentByIdNumber, getAgents) use unified resolveAddressFields() for address resolution. Column whitelists updated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update AgentService for dual-write location management</name>
  <files>src/Agents/Services/AgentService.php, src/Agents/Repositories/AgentRepository.php</files>
  <action>
**AgentService changes — Dual-Write via location management:**

1. No new imports needed — syncAddressToLocation uses `wecoza_db()` directly (global helper), not LocationsModel

2. Add a new private method `syncAddressToLocation(array $addressData, ?int $existingLocationId = null): ?int` that:
   a. Maps agent address fields to locations table fields:
      - `street_address` ← `residential_address_line` (append `, address_line_2` if not empty)
      - `suburb` ← `residential_suburb`
      - `town` ← `city`
      - `province` ← `province`
      - `postal_code` ← `residential_postal_code`
   b. If ALL address fields are empty, return null (no location to create)
   c. If `$existingLocationId` is not null:
      - Update existing location via direct SQL UPDATE using `wecoza_db()->update()` with parameterized queries (update street_address, suburb, town, province, postal_code, updated_at). Do NOT update longitude/latitude — preserve existing values.
      - Return `$existingLocationId`
   d. If `$existingLocationId` is null:
      - Check for existing duplicate via direct SQL SELECT:
        ```sql
        SELECT location_id FROM public.locations
        WHERE LOWER(street_address) = LOWER(:street_address)
          AND LOWER(suburb) = LOWER(:suburb)
          AND LOWER(town) = LOWER(:town)
          AND LOWER(province) = LOWER(:province)
          AND postal_code = :postal_code
        LIMIT 1
        ```
      - If exact match found, reuse that location_id
      - Otherwise create new location via direct SQL INSERT using `wecoza_db()->insert()` with parameterized queries:
        ```php
        $payload = [
            'street_address' => $locationData['street_address'],
            'suburb'         => $locationData['suburb'],
            'town'           => $locationData['town'],
            'province'       => $locationData['province'],
            'postal_code'    => $locationData['postal_code'],
            'longitude'      => null,
            'latitude'       => null,
            'created_at'     => current_time('mysql'),
            'updated_at'     => current_time('mysql'),
        ];
        $locationId = wecoza_db()->insert('public.locations', $payload);
        ```
      - Return the new/reused location_id
   e. On any failure, log via `wecoza_log()` and return null (graceful degradation — agent save still succeeds with inline columns)

   **CRITICAL: Do NOT use LocationsModel::create() or LocationsModel::validate().** LocationsModel::validate() requires non-null longitude and latitude (lines 56-69 in LocationsModel.php), which agent forms do not capture. The locations DB table itself has NO NOT NULL constraint on these columns — only the PHP validate() method enforces it. By using direct SQL via wecoza_db(), we bypass this validation entirely. This is intentional and safe since coordinates are optional for agent addresses.

3. Update `handleAgentFormSubmission()` method:
   - AFTER validation passes but BEFORE calling `$this->repository->createAgent()` or `$this->repository->updateAgent()`:
     a. Extract address fields from `$data`
     b. Determine existing location_id: if updating, get it from `$currentAgent['location_id'] ?? null`
     c. Call `$locationId = $this->syncAddressToLocation($data, $existingLocationId)`
     d. If `$locationId` is not null, set `$data['location_id'] = $locationId`
   - The repository's createAgent/updateAgent will then save location_id to the agents table (dual-write: address fields still go to old columns via existing sanitization, AND location_id links to normalized record)

**AgentRepository changes — Ensure dual-write works:**

1. Add `'location_id'` to the `sanitizeAgentData()` method's fields array:
   ```php
   'location_id' => 'absint',
   ```
   BUT with special handling: if the value is 0 or empty, set to null (to avoid FK violation). Add this after the main loop:
   ```php
   if (isset($cleanData['location_id']) && empty($cleanData['location_id'])) {
       $cleanData['location_id'] = null;
   }
   ```

**IMPORTANT implementation details:**
- Dual-write means: old address columns STILL get written (existing sanitizeAgentData handles this), AND location_id gets set
- Location creation uses direct SQL via `wecoza_db()->insert()` — NOT LocationsModel::create(). This is deliberate: LocationsModel::validate() requires non-null longitude/latitude (lines 56-69), but agent forms don't capture coordinates. The DB has NO NOT NULL constraint on these columns, so null is valid at the SQL level.
- Do NOT add `use WeCoza\Clients\Models\LocationsModel;` — we bypass the model entirely
- Duplicate detection uses direct SQL with case-insensitive comparison on all 5 address fields (street_address, suburb, town, province, postal_code) — NOT LocationsModel::checkDuplicates() which uses flexible LIKE matching
- Graceful degradation: if location sync fails, the agent still saves with inline address columns — no data loss
  </action>
  <verify>
1. `php -l src/Agents/Services/AgentService.php` — no syntax errors
2. `php -l src/Agents/Repositories/AgentRepository.php` — no syntax errors
3. Grep for `syncAddressToLocation` in AgentService — should appear in method definition and handleAgentFormSubmission
4. Grep for `wecoza_db()` in AgentService syncAddressToLocation — should appear for direct SQL insert/update/select (NOT LocationsModel)
5. Grep for `LocationsModel` in AgentService — should NOT appear (we bypass the model entirely)
6. Grep for `location_id` in AgentRepository sanitizeAgentData — should be present with null handling
7. Verify the data flow: collectFormData() → validate() → syncAddressToLocation() → createAgent/updateAgent with location_id
  </verify>
  <done>
AgentService handles location creation/update during form submission via syncAddressToLocation(). Dual-write implemented: address data goes to both old inline columns AND locations table via location_id FK. Direct SQL via wecoza_db() used instead of LocationsModel to bypass longitude/latitude validation. Graceful degradation on location sync failure. AgentRepository sanitization handles location_id with null coercion for empty values.
  </done>
</task>

</tasks>

<verification>
- All three PHP files pass `php -l` syntax check
- AgentRepository read methods use LEFT JOIN with fallback
- AgentRepository write methods include location_id in whitelists
- AgentService creates/updates location records during form submission
- No changes to return types or data shapes — backward compatible
- Address resolution centralized in resolveAddressFields() (DRY)
- Location sync centralized in syncAddressToLocation() (DRY)
- LocationsModel NOT used — direct SQL avoids longitude/latitude validation incompatibility
</verification>

<success_criteria>
- Agent CRUD operations return address data from locations table (with fallback)
- Agent form submissions write to both old columns and locations table
- No breaking changes to existing consumers (controllers, AJAX handlers, views)
- Direct SQL via wecoza_db() used for location CRUD — LocationsModel bypassed to avoid longitude/latitude validation
</success_criteria>

<output>
After completion, create `.planning/phases/38-address-storage-normalization/38-02-SUMMARY.md`
</output>
