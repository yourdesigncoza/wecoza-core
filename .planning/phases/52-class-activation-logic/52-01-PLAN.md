---
phase: 52-class-activation-logic
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - schema/class_status_migration.sql
  - core/Helpers/functions.php
  - src/Classes/Models/ClassModel.php
  - src/Classes/Repositories/ClassRepository.php
autonomous: true
requirements: [WEC-179, WEC-180]

must_haves:
  truths:
    - "wecoza_resolve_class_status() returns 'draft' for NULL/empty class_status with no order_nr"
    - "wecoza_resolve_class_status() returns 'active' for NULL class_status with non-empty order_nr"
    - "ClassModel hydrate() reads class_status and applies fallback"
    - "ClassModel isDraft/isActive/isStopped use classStatus property"
    - "ClassRepository includes class_status in insert, update, filter, and SELECT columns"
  artifacts:
    - path: "schema/class_status_migration.sql"
      provides: "DDL for class_status column, backfill, CHECK constraint, class_status_history table"
      contains: "ALTER TABLE classes ADD COLUMN class_status"
    - path: "core/Helpers/functions.php"
      provides: "Centralized status fallback helper (CC1)"
      contains: "function wecoza_resolve_class_status"
    - path: "src/Classes/Models/ClassModel.php"
      provides: "classStatus property with getter/setter, rewritten status methods"
      contains: "classStatus"
    - path: "src/Classes/Repositories/ClassRepository.php"
      provides: "class_status in column whitelists and getAllClasses SELECT"
      contains: "class_status"
  key_links:
    - from: "src/Classes/Models/ClassModel.php"
      to: "core/Helpers/functions.php"
      via: "wecoza_resolve_class_status() called in hydrate()"
      pattern: "wecoza_resolve_class_status"
---

<objective>
Create the database migration SQL for the `class_status` column and `class_status_history` table, add the centralized `wecoza_resolve_class_status()` helper to functions.php, and update ClassModel + ClassRepository to use the new column.

Purpose: This is the foundational layer — every other plan depends on the class_status column existing and the model/repository being able to read/write it.
Output: Migration SQL file, helper function, updated model and repository.
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-class-activation-logic/52-RESEARCH.md
@/home/laudes/.claude/plans/snoopy-wobbling-fountain.md

Key references:
- ClassModel: src/Classes/Models/ClassModel.php — isDraft() at ~line 416, hydrate() at ~line 71, toArray() at ~line 543
- ClassRepository: src/Classes/Repositories/ClassRepository.php — getAllowedInsertColumns() at ~line 67, getAllClasses() SELECT at ~line 514
- functions.php: core/Helpers/functions.php — append new helper at end
- Research confirmed: class_status column does NOT exist yet, class_status_history table does NOT exist
- Research confirmed: class_attendance_sessions table also does NOT exist (Phase 48 SQL unexecuted). Include reminder in migration file header.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DB migration SQL file</name>
  <files>schema/class_status_migration.sql</files>
  <action>
Create `schema/class_status_migration.sql` with the following SQL statements:

1. Header comment block noting:
   - This migration adds the class activation status system (WEC-179/WEC-180)
   - User must execute manually against PostgreSQL
   - REMINDER: If `class_attendance_sessions` table does not exist yet (Phase 48), also execute `schema/class_attendance_sessions.sql` first

2. Add `class_status` column:
   ```sql
   ALTER TABLE classes ADD COLUMN class_status VARCHAR(20) NOT NULL DEFAULT 'draft';
   ```

3. Backfill existing data:
   ```sql
   UPDATE classes SET class_status = 'active' WHERE order_nr IS NOT NULL AND order_nr != '';
   UPDATE classes SET class_status = 'draft' WHERE order_nr IS NULL OR order_nr = '';
   ```

4. Add CHECK constraint:
   ```sql
   ALTER TABLE classes ADD CONSTRAINT chk_class_status
     CHECK (class_status IN ('draft', 'active', 'stopped'));
   ```

5. Create `class_status_history` table:
   ```sql
   CREATE TABLE class_status_history (
       id SERIAL PRIMARY KEY,
       class_id INTEGER NOT NULL REFERENCES classes(class_id),
       old_status VARCHAR(20) NOT NULL,
       new_status VARCHAR(20) NOT NULL,
       reason VARCHAR(50),
       notes TEXT,
       changed_by INTEGER NOT NULL,
       changed_at TIMESTAMP NOT NULL DEFAULT NOW()
   );
   CREATE INDEX idx_class_status_history_class_id ON class_status_history(class_id);
   ```

No PHP execution — this is a SQL file the user runs manually.
  </action>
  <verify>
    <automated>test -f /opt/lampp/htdocs/wecoza/wp-content/plugins/wecoza-core/schema/class_status_migration.sql && grep -q "class_status" /opt/lampp/htdocs/wecoza/wp-content/plugins/wecoza-core/schema/class_status_migration.sql && grep -q "class_status_history" /opt/lampp/htdocs/wecoza/wp-content/plugins/wecoza-core/schema/class_status_migration.sql && echo "PASS" || echo "FAIL"</automated>
    <manual>User reviews SQL and executes against PostgreSQL</manual>
  </verify>
  <done>Migration SQL file exists at schema/class_status_migration.sql with ALTER TABLE, backfill UPDATEs, CHECK constraint, and class_status_history CREATE TABLE</done>
</task>

<task type="auto">
  <name>Task 2: Add wecoza_resolve_class_status helper and update ClassModel + ClassRepository</name>
  <files>core/Helpers/functions.php, src/Classes/Models/ClassModel.php, src/Classes/Repositories/ClassRepository.php</files>
  <action>
**A. core/Helpers/functions.php** — Append `wecoza_resolve_class_status()` helper (CC1):
```php
function wecoza_resolve_class_status(array $class): string
{
    return $class['class_status'] ?? (empty($class['order_nr']) ? 'draft' : 'active');
}
```
Place after the last existing function in the file.

**B. src/Classes/Models/ClassModel.php** — Update the model:

1. Add property near line 56 (with other properties): `private string $classStatus = 'draft';`

2. Add getter/setter:
   ```php
   public function getClassStatus(): string { return $this->classStatus; }
   public function setClassStatus(string $status): void { $this->classStatus = $status; }
   ```

3. In `hydrate()` method (~line 71): add reading of `class_status` from data array. Use `wecoza_resolve_class_status()` fallback:
   ```php
   $this->classStatus = wecoza_resolve_class_status($data);
   ```
   Place this after the existing property assignments in hydrate().

4. Rewrite status methods (~lines 416-426) replacing the old `order_nr`-based logic:
   ```php
   public function isDraft(): bool { return $this->classStatus === 'draft'; }
   public function isActive(): bool { return $this->classStatus === 'active'; }
   public function isStopped(): bool { return $this->classStatus === 'stopped'; }
   public function getStatus(): string { return ucfirst($this->classStatus); }
   public function isAttendanceAllowed(): bool { return $this->isActive(); }
   ```
   Remove the old `isDraft()` and `isActive()` that used `empty($this->orderNr)`.

5. In `toArray()` (~line 543): add `'class_status' => $this->classStatus` to the returned array.

6. In `save()` and `update()` column arrays: add `'class_status'` if these methods have explicit column lists.

**C. src/Classes/Repositories/ClassRepository.php** — Update column whitelists:

1. In `getAllowedInsertColumns()` (~line 67): add `'class_status'` to the array
   (This automatically propagates to `getAllowedUpdateColumns()` since it calls `getAllowedInsertColumns()`)

2. In `getAllowedFilterColumns()` (~line 55): add `'class_status'`

3. In `getAllClasses()` SELECT statement (~line 514): add `c.class_status` to the column list

**Important notes:**
- Do NOT break existing `order_nr`-based logic that other code depends on — the fallback helper ensures backward compatibility
- Add a code comment in ClassModel near the status methods: "Note: class_status is the explicit status column. ClassController::isClassCurrentlyStopped() checks stop_restart_dates JSON for schedule pauses — a separate concept." (per Research Pitfall 8)
  </action>
  <verify>
    <automated>grep -q "wecoza_resolve_class_status" /opt/lampp/htdocs/wecoza/wp-content/plugins/wecoza-core/core/Helpers/functions.php && grep -q "classStatus" /opt/lampp/htdocs/wecoza/wp-content/plugins/wecoza-core/src/Classes/Models/ClassModel.php && grep -q "class_status" /opt/lampp/htdocs/wecoza/wp-content/plugins/wecoza-core/src/Classes/Repositories/ClassRepository.php && echo "PASS" || echo "FAIL"</automated>
  </verify>
  <done>wecoza_resolve_class_status() helper exists in functions.php. ClassModel has classStatus property with getter/setter, hydrate reads it with fallback, status methods use property instead of order_nr. ClassRepository includes class_status in all column whitelists and SELECT.</done>
</task>

</tasks>

<verification>
1. `schema/class_status_migration.sql` contains valid PostgreSQL DDL
2. `wecoza_resolve_class_status()` is callable and returns correct values for all input combinations
3. `ClassModel::isDraft()`, `isActive()`, `isStopped()` use `classStatus` property
4. `ClassModel::hydrate()` calls `wecoza_resolve_class_status()` for fallback
5. `ClassRepository` column whitelists include `class_status`
</verification>

<success_criteria>
- Migration SQL file ready for user execution
- Helper function provides centralized status resolution with backward compatibility
- Model and repository fully support the new class_status column
- No breaking changes to existing functionality (fallback ensures compatibility during migration window)
</success_criteria>

<output>
After completion, create `.planning/phases/52-class-activation-logic/52-01-SUMMARY.md`
</output>
