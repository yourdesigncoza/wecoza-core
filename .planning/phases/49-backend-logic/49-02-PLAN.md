---
phase: 49-backend-logic
plan: 02
type: execute
wave: 2
depends_on: ["49-01"]
files_modified:
  - src/Classes/Services/AttendanceService.php
autonomous: true
requirements: [BACK-05, BACK-06, SESS-01, SESS-02, SESS-04, SESS-05]

must_haves:
  truths:
    - "generateSessionList returns scheduled session dates with correct start/end times and hours by delegating to ScheduleService::generateScheduleEntries()"
    - "validateSessionDate rejects dates that are NOT in the generated schedule for a class"
    - "captureAttendance creates a session record with status=captured, then calls ProgressionService::logHours() for each learner with session_id and created_by"
    - "markException creates a session record with status=client_cancelled or agent_absent and zero hours — no learner_hours_log rows created"
    - "deleteAndReverseHours removes the session record and recalculates each affected learner's LP accumulators from remaining hours log entries"
    - "Captured sessions cannot be re-captured (service checks for existing session before insert)"
  artifacts:
    - path: "src/Classes/Services/AttendanceService.php"
      provides: "Business logic for attendance capture, exception marking, and hours reversal"
      contains: "class AttendanceService"
  key_links:
    - from: "src/Classes/Services/AttendanceService.php"
      to: "src/Classes/Repositories/AttendanceRepository.php"
      via: "constructor injection"
      pattern: "new AttendanceRepository"
    - from: "src/Classes/Services/AttendanceService.php"
      to: "src/Classes/Services/ScheduleService.php"
      via: "static method call"
      pattern: "ScheduleService::generateScheduleEntries"
    - from: "src/Classes/Services/AttendanceService.php"
      to: "src/Learners/Services/ProgressionService.php"
      via: "instance method call"
      pattern: "progressionService->logHours"
    - from: "src/Classes/Services/AttendanceService.php"
      to: "src/Classes/Repositories/ClassRepository.php"
      via: "static method call"
      pattern: "ClassRepository::getSingleClass"
---

<objective>
Create AttendanceService encapsulating all attendance business logic: session generation from class schedule, date validation, attendance capture with hours propagation, exception marking (Client Cancelled / Agent Absent), and admin delete with hours reversal.

Purpose: Single service class that orchestrates AttendanceRepository, ScheduleService, ProgressionService, and ClassRepository — all downstream AJAX handlers delegate to this.
Output: `src/Classes/Services/AttendanceService.php` with five public methods.
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/49-backend-logic/49-01-SUMMARY.md
@src/Classes/Services/ScheduleService.php
@src/Classes/Repositories/ClassRepository.php
@src/Learners/Services/ProgressionService.php
@src/Learners/Models/LearnerProgressionModel.php
@schema/class_attendance_sessions.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AttendanceService with session generation and date validation</name>
  <files>src/Classes/Services/AttendanceService.php</files>
  <action>
Create `src/Classes/Services/AttendanceService.php` in namespace `WeCoza\Classes\Services`.

**Constructor:** Instantiate `AttendanceRepository` and `ProgressionService` as private properties.

**Private helper — getClassData(int $classId): array**
Call `ClassRepository::getSingleClass($classId)`. Throw Exception if null ("Class not found: {classId}").

**Private helper — parseScheduleData(array $classData): array**
Extract `schedule_data` from classData. Handle both string (json_decode) and array forms. Throw Exception if empty/invalid.

**Private helper — calculateHoursFromTimes(string $startTime, string $endTime): float**
Return `(strtotime($endTime) - strtotime($startTime)) / 3600`. Return 0 if invalid.

**Method 1: generateSessionList(int $classId): array**

1. Call `getClassData($classId)` to get class record.
2. Parse `schedule_data` from the class. Extract: `pattern`, `startDate`, `endDate`, `timeData`, `selectedDays`, `dayOfMonth`.

3. **CRITICAL FORMAT MAPPING:** The DB stores timeData with `perDayTimes` containing `start_time`/`end_time` keys, but `ScheduleService::getTimesForDay()` expects `perDay` with `startTime`/`endTime`. Before calling generateScheduleEntries, transform the timeData:
   - If `timeData['perDayTimes']` exists, convert to `timeData['perDay']` format:
     ```php
     foreach ($timeData['perDayTimes'] as $day => $times) {
         $timeData['perDay'][$day] = [
             'startTime' => $times['start_time'] ?? $times['startTime'] ?? '09:00',
             'endTime'   => $times['end_time'] ?? $times['endTime'] ?? '17:00',
         ];
     }
     ```
   - This handles both old `start_time` and new `startTime` key formats in the DB.

4. Create DateTime objects from startDate/endDate. If endDate is empty/null, use today's date as the effective end date (sessions are only generated up to now for attendance purposes).
5. Call `ScheduleService::generateScheduleEntries($pattern, $startDate, $endDate, $timeData, $selectedDays, $dayOfMonth)`.
6. Get existing sessions from `$this->repository->findByClass($classId)` and index by session_date.
7. Map each schedule entry to a result array:
   ```php
   [
       'date'            => $entry['date'],
       'day'             => date('l', strtotime($entry['date'])),
       'start_time'      => $entry['start_time'],
       'end_time'        => $entry['end_time'],
       'scheduled_hours' => calculateHoursFromTimes($entry['start_time'], $entry['end_time']),
       'session_id'      => $existingSession['session_id'] ?? null,
       'status'          => $existingSession['status'] ?? 'pending',
       'captured_by'     => $existingSession['captured_by'] ?? null,
       'captured_at'     => $existingSession['captured_at'] ?? null,
       'notes'           => $existingSession['notes'] ?? null,
   ]
   ```
8. Return the array sorted by date ascending (already sorted from ScheduleService).

**Method 2: validateSessionDate(int $classId, string $sessionDate): bool**

1. Call `generateSessionList($classId)`.
2. Check if any entry has `'date' === $sessionDate`.
3. Return true if found, false if not.

Follow established patterns: `declare(strict_types=1)`, ABSPATH guard, use statements for all dependencies, try/catch with `wecoza_sanitize_exception()`.
  </action>
  <verify>
    <automated>cd /opt/lampp/htdocs/wecoza/wp-content/plugins/wecoza-core && php -l src/Classes/Services/AttendanceService.php</automated>
    <manual>Verify: generateSessionList reads schedule_data and delegates to ScheduleService, validateSessionDate checks date membership, perDayTimes -> perDay format mapping present</manual>
  </verify>
  <done>AttendanceService has generateSessionList() that correctly maps DB schedule format to ScheduleService input and merges existing session data, and validateSessionDate() that rejects non-scheduled dates. BACK-05 and BACK-06 addressed.</done>
</task>

<task type="auto">
  <name>Task 2: Add captureAttendance, markException, and deleteAndReverseHours methods</name>
  <files>src/Classes/Services/AttendanceService.php</files>
  <action>
Add three more public methods to AttendanceService (in the same file created in Task 1).

**Method 3: captureAttendance(int $classId, string $sessionDate, array $learnerHours, int $capturedBy): array**

`$learnerHours` is an array of `['learner_id' => int, 'hours_present' => float]` entries.

1. Call `validateSessionDate($classId, $sessionDate)`. Throw Exception if false: "Invalid session date: not a scheduled date for this class".
2. Check for existing session: `$this->repository->findByClassAndDate($classId, $sessionDate)`. If found AND status !== 'pending', throw Exception: "Session already captured or marked — cannot re-capture". If found AND status === 'pending', use that session_id for update. If not found, create new.
3. Get scheduled hours from `generateSessionList` for this date (the `scheduled_hours` value from the matching entry).
4. Create or update session record:
   ```php
   $sessionData = [
       'class_id'        => $classId,
       'session_date'    => $sessionDate,
       'status'          => 'captured',
       'scheduled_hours' => $scheduledHours,
       'captured_by'     => $capturedBy,
       'captured_at'     => current_time('mysql'),
       'updated_at'      => current_time('mysql'),
   ];
   ```
   If creating: add `'created_at' => current_time('mysql')` and call `createSession()`.
   If updating pending: call `updateSession($existingSessionId, $sessionData)`.
5. For each learner in $learnerHours, call:
   ```php
   $this->progressionService->logHours(
       learnerId:    $learnerHours['learner_id'],
       hoursTrained: $scheduledHours,      // Same for all learners — session duration
       hoursPresent: $learnerHours['hours_present'],
       source:       'attendance',
       notes:        "Attendance capture for {$sessionDate}",
       sessionId:    $sessionId,
       createdBy:    $capturedBy
   );
   ```
   Wrap each logHours call in try/catch. If it fails (learner has no in-progress LP), collect the error but continue with other learners. Do NOT abort the whole capture.
6. Return `['session_id' => $sessionId, 'captured_count' => $successCount, 'errors' => $errors]`.

**Method 4: markException(int $classId, string $sessionDate, string $exceptionType, int $markedBy, ?string $notes = null): array**

1. Validate `$exceptionType` is one of `['client_cancelled', 'agent_absent']`. Throw Exception if not.
2. Call `validateSessionDate($classId, $sessionDate)`. Throw if false.
3. Check existing: `findByClassAndDate`. If exists and status !== 'pending', throw "Session already captured or marked".
4. Get scheduled hours from `generateSessionList`.
5. Create or update session:
   ```php
   $sessionData = [
       'class_id'        => $classId,
       'session_date'    => $sessionDate,
       'status'          => $exceptionType,
       'scheduled_hours' => $scheduledHours,
       'notes'           => $notes,
       'captured_by'     => $markedBy,
       'captured_at'     => current_time('mysql'),
       'updated_at'      => current_time('mysql'),
   ];
   ```
   NO learner hours logged — zero hours means no logHours() calls at all. This is the key business rule: exceptions don't count toward hours_trained.
6. Return `['session_id' => $sessionId, 'status' => $exceptionType]`.

**Method 5: deleteAndReverseHours(int $sessionId, int $deletedBy): bool**

1. Get session from `$this->repository->findById($sessionId)`. Throw if not found.
2. If session status is 'pending', just delete — no hours to reverse: `$this->repository->deleteSession($sessionId)`.
3. If session status is 'captured':
   a. Get learner hours for this session via `$this->repository->getSessionsWithLearnerHours($sessionId)`.
   b. Delete the session record: `$this->repository->deleteSession($sessionId)`.
   c. For each learner that had hours logged, recalculate their LP accumulators by calling `$this->progressionService->recalculateHours($trackingId)`.
      - To find the tracking_id, query `learner_hours_log` for rows with this session_id to get tracking_ids BEFORE deleting.
      - Actually, we need to: (a) read the log entries for this session_id first, (b) delete the learner_hours_log rows for this session_id, (c) delete the session, (d) recalculate each affected LP.
      - Add a private helper `deleteHoursLogBySessionId(int $sessionId): array` that:
        ```sql
        SELECT DISTINCT tracking_id FROM learner_hours_log WHERE session_id = :session_id
        ```
        then:
        ```sql
        DELETE FROM learner_hours_log WHERE session_id = :session_id
        ```
        Returns the array of tracking_ids that were affected.
   d. For each tracking_id, call `$this->progressionService->recalculateHours($trackingId)`.
4. If session status is 'client_cancelled' or 'agent_absent', just delete — no hours were logged.
5. Log the deletion: `wecoza_log("Session {$sessionId} deleted by user {$deletedBy}", 'info')`.
6. Return true on success.

Wrap the entire delete+reverse in a try/catch. The hours log deletion and session deletion should ideally be in a transaction. Use `$this->repository->beginTransaction()` / `commit()` / `rollback()` — but those are protected on BaseRepository. Instead, access the PDO directly:
```php
$pdo = wecoza_db()->getPdo();
$pdo->beginTransaction();
try {
    // delete hours log rows
    // delete session
    $pdo->commit();
    // recalculate (outside transaction — read-only recalc)
} catch (Exception $e) {
    $pdo->rollBack();
    throw $e;
}
```
  </action>
  <verify>
    <automated>cd /opt/lampp/htdocs/wecoza/wp-content/plugins/wecoza-core && php -l src/Classes/Services/AttendanceService.php</automated>
    <manual>Verify: captureAttendance calls logHours for each learner, markException creates zero-hours session, deleteAndReverseHours removes hours log entries and recalculates LPs</manual>
  </verify>
  <done>AttendanceService has five public methods covering all attendance business logic. captureAttendance propagates hours to learner_lp_tracking via logHours. markException creates zero-hours sessions. deleteAndReverseHours reverses accumulated hours. SESS-01, SESS-02, SESS-04, SESS-05 addressed.</done>
</task>

</tasks>

<verification>
- `php -l src/Classes/Services/AttendanceService.php` — no syntax errors
- grep confirms: `generateSessionList`, `validateSessionDate`, `captureAttendance`, `markException`, `deleteAndReverseHours`
- grep confirms: `ScheduleService::generateScheduleEntries` — schedule delegation
- grep confirms: `progressionService->logHours` — hours propagation
- grep confirms: `recalculateHours` — hours reversal
- grep confirms: `client_cancelled.*agent_absent` — exception types handled
- grep confirms: `perDayTimes.*perDay` — format mapping present
</verification>

<success_criteria>
AttendanceService encapsulates all attendance business rules:
1. Sessions generated from class schedule_data via ScheduleService delegation
2. Date validation rejects non-scheduled dates
3. Capture logs per-learner hours via ProgressionService::logHours with session_id audit trail
4. Exceptions create zero-hours sessions (no logHours calls)
5. Admin delete reverses hours by removing log entries and recalculating LP accumulators
6. Captured sessions cannot be re-captured (status check)
</success_criteria>

<output>
After completion, create `.planning/phases/49-backend-logic/49-02-SUMMARY.md`
</output>
