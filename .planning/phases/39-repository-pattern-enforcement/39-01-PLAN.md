---
phase: 39-repository-pattern-enforcement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/Learners/Repositories/LearnerRepository.php
  - src/Clients/Repositories/ClientRepository.php
  - .planning/phases/39-repository-pattern-enforcement/39-SQL-AUDIT.md
autonomous: true

must_haves:
  truths:
    - "Every direct SQL query across all repositories is catalogued with classification"
    - "ClientRepository simple queries use BaseRepository findBy methods"
    - "LearnerRepository insert validates FK then delegates bulk of work to parent::insert"
  artifacts:
    - path: ".planning/phases/39-repository-pattern-enforcement/39-SQL-AUDIT.md"
      provides: "Complete audit of all direct SQL across every repository"
      contains: "REPLACEABLE"
    - path: "src/Clients/Repositories/ClientRepository.php"
      provides: "Refactored client queries using BaseRepository methods"
      contains: "findBy"
    - path: "src/Learners/Repositories/LearnerRepository.php"
      provides: "Refactored learner insert with parent delegation"
      contains: "parent::insert"
  key_links:
    - from: "src/Clients/Repositories/ClientRepository.php"
      to: "core/Abstract/BaseRepository.php"
      via: "findBy/findOneBy method calls"
      pattern: "findBy|findOneBy"
    - from: ".planning/phases/39-repository-pattern-enforcement/39-SQL-AUDIT.md"
      to: "All *Repository.php files"
      via: "Documents every direct SQL query"
      pattern: "REPLACEABLE|JUSTIFIED"
---

<objective>
Audit all direct SQL queries across every repository and refactor LearnerRepository + ClientRepository to use BaseRepository methods where appropriate.

Purpose: REPO-01 (full audit), REPO-02 (LearnerRepository), REPO-04 (ClientRepository) -- establish the audit document and refactor the two simpler repositories first.

Output: SQL audit document + refactored LearnerRepository and ClientRepository
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@core/Abstract/BaseRepository.php
@src/Learners/Repositories/LearnerRepository.php
@src/Clients/Repositories/ClientRepository.php
@src/Agents/Repositories/AgentRepository.php
@src/Learners/Repositories/LearnerProgressionRepository.php
@src/Classes/Repositories/ClassRepository.php
@src/Events/Repositories/ClassEventRepository.php
@src/Events/Repositories/ClassTaskRepository.php
@src/Events/Repositories/MaterialTrackingRepository.php
@src/Clients/Repositories/LocationRepository.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create comprehensive SQL audit document for all repositories</name>
  <files>.planning/phases/39-repository-pattern-enforcement/39-SQL-AUDIT.md</files>
  <action>
Create a markdown document that catalogues EVERY direct SQL query in every repository file. For each query, record:
- Repository class and method name
- Query type (SELECT/INSERT/UPDATE/DELETE)
- Whether it uses BaseRepository parent methods or manual SQL
- Classification: REPLACEABLE (can use findBy/insert/update/delete/deleteBy/findById/findOneBy/count) or JUSTIFIED (needs custom SQL)
- If JUSTIFIED, one-line reason (e.g., "Complex JOINs across 4 tables", "CTE with window functions", "DISTINCT ON clause", "JSONB operations", "Operates on different table than $table")

Repositories to audit (read each file):
1. LearnerRepository (src/Learners/Repositories/)
2. AgentRepository (src/Agents/Repositories/)
3. ClientRepository (src/Clients/Repositories/)
4. LearnerProgressionRepository (src/Learners/Repositories/)
5. ClassRepository (src/Classes/Repositories/)
6. ClassEventRepository (src/Events/Repositories/)
7. ClassTaskRepository (src/Events/Repositories/)
8. MaterialTrackingRepository (src/Events/Repositories/)
9. LocationRepository (src/Clients/Repositories/)

Format as a table per repository with columns: Method | Query Type | Uses Parent? | Classification | Reason

End with a summary section:
- Total direct SQL queries
- Replaceable count
- Justified count
- Percentage that can be replaced

Key classifications to get right:
- AgentRepository::createAgent() uses wecoza_db()->insert() directly -- REPLACEABLE (should use parent::insert)
- AgentRepository::updateAgent() uses wecoza_db()->update() directly -- REPLACEABLE (should use parent::update)
- AgentRepository::deleteAgent() soft-delete -- REPLACEABLE (should use parent::update)
- AgentRepository::deleteAgentPermanently() uses wecoza_db()->delete() -- REPLACEABLE (should use parent::delete)
- AgentRepository::getAgent/getAgentByEmail/getAgentByIdNumber -- JUSTIFIED (LEFT JOIN to locations)
- AgentRepository::getAgents -- JUSTIFIED (complex search + pagination + JOIN)
- AgentRepository meta/notes/absences methods -- JUSTIFIED (different tables)
- ClientRepository::getMainClients() -- REPLACEABLE (findBy with null criteria or findOneBy)
- ClientRepository::getBranchClients() -- REPLACEABLE (findBy with main_client_id criteria)
- ClientRepository::searchClients() -- JUSTIFIED (ILIKE search not supported by BaseRepository)
- LearnerRepository::insert() -- PARTIALLY REPLACEABLE (FK validation then parent::insert)
- LearnerRepository mapped queries -- JUSTIFIED (complex JOINs, CTEs)
- LearnerRepository dropdown methods -- JUSTIFIED (different tables)
- LearnerRepository portfolio/sponsors -- JUSTIFIED (different tables, transactional)
- ClassEventRepository::findPendingForProcessing -- REPLACEABLE (findBy with notification_status='pending')
- ClassEventRepository::findByEntity -- REPLACEABLE (findBy with entity_type + entity_id)
- ClassEventRepository::updateStatus -- already uses parent::update (GOOD)
- ClassEventRepository::updateAiSummary -- JUSTIFIED (CURRENT_TIMESTAMP + json_encode)
- ClassEventRepository::markSent/markViewed/markAcknowledged -- JUSTIFIED (CURRENT_TIMESTAMP conditions)
- ClassEventRepository::getTimeline -- JUSTIFIED (cursor pagination)
- ClassEventRepository::getUnreadCount -- JUSTIFIED (COUNT with IS NULL condition, no criteria support in parent::count for IS NULL)
- All ClassTaskRepository methods -- JUSTIFIED (complex multi-table JOINs)
- All MaterialTrackingRepository methods -- JUSTIFIED (UPSERT, JSONB operations, multi-table)
- All LearnerProgressionRepository methods -- JUSTIFIED (complex JOINs via baseQuery, different tables for hours log/portfolio)
- ClassRepository static methods -- JUSTIFIED (static context, complex joins, reference data from other tables)
- ClassRepository::insertClass/updateClass/deleteClass -- REPLACEABLE (should delegate to parent::insert/update/delete)
- LocationRepository::findByCoordinates -- JUSTIFIED (Haversine formula)
- LocationRepository::checkDuplicates -- JUSTIFIED (LOWER() case-insensitive matching)
  </action>
  <verify>
File exists at .planning/phases/39-repository-pattern-enforcement/39-SQL-AUDIT.md. Contains a table for each of the 9 repositories. Summary section shows total, replaceable, justified counts. Every method with direct SQL is listed.
  </verify>
  <done>
Every direct SQL query across all 9 repository files is catalogued. Each has REPLACEABLE or JUSTIFIED classification with reason.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor ClientRepository and LearnerRepository to use BaseRepository methods</name>
  <files>src/Clients/Repositories/ClientRepository.php, src/Learners/Repositories/LearnerRepository.php</files>
  <action>
**ClientRepository refactoring:**

1. `getMainClients()` -- Currently manual SQL: `SELECT ... WHERE main_client_id IS NULL ORDER BY client_name`.
   - BaseRepository::findBy() doesn't support selecting specific columns, but it does support null criteria.
   - However, getMainClients() selects only 3 columns (client_id, client_name, company_registration_nr) for performance.
   - Add 'main_client_id' to getAllowedFilterColumns() if not already present.
   - Reclassify as JUSTIFIED due to column subset selection. Add a comment: `// Complex query: selects column subset for performance (BaseRepository selects *)`
   - Actually, the overhead of SELECT * vs 3 columns on a small clients table is negligible. Replace with:
     ```php
     public function getMainClients(): array
     {
         return $this->findBy(['main_client_id' => null], 1000, 0, 'client_name', 'ASC');
     }
     ```
   - Wait -- BaseRepository::findBy() handles `null` values with `IS NULL` (line 258-259 in BaseRepository). This will work.
   - But findBy returns all columns (SELECT *). The original only selects 3 columns. For a small table this is fine.
   - Need to add 'main_client_id' to getAllowedFilterColumns() and 'client_name' to getAllowedOrderColumns() (client_name is already there).

2. `getBranchClients()` -- Currently manual SQL: `SELECT ... WHERE main_client_id = :main_client_id ORDER BY client_name`.
   - Replace with `findBy(['main_client_id' => $mainClientId], 1000, 0, 'client_name', 'ASC')`.
   - main_client_id already in getAllowedFilterColumns(). client_name already in getAllowedOrderColumns().

3. `searchClients()` -- Keep as-is. Add comment: `// Complex query: ILIKE search not supported by BaseRepository findBy`

**LearnerRepository refactoring:**

1. `insert()` -- Currently overrides parent with FK validation + manual SQL.
   - Refactor to: validate FK, then call `return parent::insert($filteredData)` instead of building SQL manually.
   - Keep the executeTransaction wrapper for the FK validation step.
   - After parent::insert returns, clear cache and return result.
   - Actually, parent::insert() doesn't run inside the transaction. Refactor to:
     ```php
     public function insert(array $data): ?int
     {
         $allowedColumns = $this->getAllowedInsertColumns();
         $filteredData = $this->filterAllowedColumns($data, $allowedColumns);
         if (empty($filteredData)) {
             error_log("WeCoza Core: LearnerRepository insert rejected - no valid columns in data");
             return null;
         }
         // Validate FK before insert
         if (!empty($filteredData['highest_qualification'])) {
             // Complex query: FK validation against learner_qualifications table
             $pdo = $this->db->getPdo();
             $stmt = $pdo->prepare("SELECT COUNT(*) FROM learner_qualifications WHERE id = :id");
             $stmt->execute(['id' => $filteredData['highest_qualification']]);
             if ($stmt->fetchColumn() == 0) {
                 error_log("WeCoza Core: Invalid highest qualification ID: " . $filteredData['highest_qualification']);
                 return null;
             }
         }
         $newId = parent::insert($filteredData);
         if ($newId !== null) {
             delete_transient('learner_db_get_learners_mappings');
         }
         return $newId;
     }
     ```
   - This removes the manual SQL construction and transaction wrapper (parent::insert handles it).
   - The FK validation is a simple pre-check that doesn't need to be in the same transaction.

2. Add `// Complex query: ...` comments to all justified methods:
   - `baseQueryWithMappings()` -- `// Complex query: CTE + 6-table JOIN for full learner data with portfolio aggregation`
   - `getLocations()` -- `// Complex query: DISTINCT ON for deduplicated location dropdowns from locations table`
   - `getQualifications()` -- `// Complex query: reads from learner_qualifications table (not $table)`
   - `getPlacementLevels()` -- `// Complex query: reads from learner_placement_level table (not $table)`
   - `getEmployers()` -- `// Complex query: reads from employers table (not $table)`
   - `getLearnersWithProgressionContext()` -- `// Complex query: dual CTE with 4-table JOIN for progression context`
   - `getActiveLPForLearner()` -- `// Complex query: 3-table JOIN with calculated progress percentage`
   - `getPortfolios()` -- `// Complex query: reads from learner_portfolios table (not $table)`
   - `savePortfolios()` -- `// Complex query: multi-table transactional portfolio upload with file I/O`
   - `deletePortfolio()` -- `// Complex query: multi-table transactional portfolio deletion with file cleanup`
   - `getSponsors()` -- `// Complex query: reads from learner_sponsors table (not $table)`
   - `saveSponsors()` -- `// Complex query: transactional replace-all on learner_sponsors table`

**Important:** Do NOT break backward compatibility. All public method signatures must remain identical. Only the internal implementation changes.

Run `php -l` on both modified files to verify syntax.
  </action>
  <verify>
Run `php -l src/Clients/Repositories/ClientRepository.php` and `php -l src/Learners/Repositories/LearnerRepository.php` -- both must parse without errors. Verify getMainClients() calls $this->findBy(), getBranchClients() calls $this->findBy(), LearnerRepository::insert() calls parent::insert(). grep for these patterns.
  </verify>
  <done>
ClientRepository::getMainClients() uses $this->findBy() with null criteria. ClientRepository::getBranchClients() uses $this->findBy(). LearnerRepository::insert() delegates to parent::insert() after FK validation. All justified queries have `// Complex query:` comments. Both files parse without errors.
  </done>
</task>

</tasks>

<verification>
1. `php -l src/Clients/Repositories/ClientRepository.php` passes
2. `php -l src/Learners/Repositories/LearnerRepository.php` passes
3. Audit document exists and covers all 9 repositories
4. grep -c "findBy" src/Clients/Repositories/ClientRepository.php shows increased count
5. grep "parent::insert" src/Learners/Repositories/LearnerRepository.php shows delegation
6. grep -c "Complex query:" src/Learners/Repositories/LearnerRepository.php shows justified bypass comments
</verification>

<success_criteria>
1. Every direct SQL query across all 9 repositories is catalogued in the audit document
2. ClientRepository::getMainClients() and getBranchClients() use BaseRepository findBy method
3. LearnerRepository::insert() delegates to parent::insert() after FK validation
4. All justified queries have `// Complex query:` comments explaining why BaseRepository insufficient
5. Both modified files pass php -l syntax check
6. No changes to public method signatures (backward compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/39-repository-pattern-enforcement/39-01-SUMMARY.md`
</output>
