---
phase: 15-bidirectional-sync
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - src/Events/Controllers/TaskController.php
  - src/Events/Services/TaskManager.php
autonomous: true

must_haves:
  truths:
    - "TaskController accepts class_id parameter instead of log_id"
    - "Completing event task updates event_dates JSONB with status, completed_by, completed_at"
    - "Completing Agent Order Number task writes note value to classes.order_nr"
    - "Reopening task clears completion metadata but preserves notes"
  artifacts:
    - path: "src/Events/Controllers/TaskController.php"
      provides: "AJAX handler using class_id parameter"
      contains: "class_id"
    - path: "src/Events/Services/TaskManager.php"
      provides: "markTaskCompleted and reopenTask methods using class_id"
      contains: "markTaskCompleted.*classId"
  key_links:
    - from: "src/Events/Controllers/TaskController.php"
      to: "src/Events/Services/TaskManager.php"
      via: "markTaskCompleted(classId, taskId, ...)"
      pattern: "markTaskCompleted\\("
    - from: "src/Events/Services/TaskManager.php"
      to: "updateEventStatus()"
      via: "JSONB update for event tasks"
      pattern: "updateEventStatus"
    - from: "src/Events/Services/TaskManager.php"
      to: "classes.order_nr"
      via: "updateClassOrderNumber for agent-order task"
      pattern: "updateClassOrderNumber"
---

<objective>
Refactor TaskController and TaskManager to use class_id and implement actual task completion/reopen persistence to event_dates JSONB.

Purpose: Enable the task dashboard to write task state changes back to the database, completing bidirectional sync.
Output: Working task completion/reopen that persists to classes.event_dates and classes.order_nr.
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-bidirectional-sync/15-RESEARCH.md
@.planning/phases/15-bidirectional-sync/15-01-SUMMARY.md
@src/Events/Controllers/TaskController.php
@src/Events/Services/TaskManager.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor TaskManager completion methods for class_id</name>
  <files>src/Events/Services/TaskManager.php</files>
  <action>
Rewrite markTaskCompleted() and reopenTask() to use class_id and call the JSONB update methods from Plan 01.

**1. Rewrite markTaskCompleted()**

Change signature from `markTaskCompleted(int $logId, ...)` to `markTaskCompleted(int $classId, ...)`.

New implementation:
```php
public function markTaskCompleted(
    int $classId,
    string $taskId,
    int $userId,
    string $timestamp,
    ?string $note = null
): TaskCollection {
    $cleanNote = $note !== null ? trim($note) : null;

    // Handle agent-order task specially
    if ($taskId === 'agent-order') {
        return $this->completeAgentOrderTask($classId, $userId, $timestamp, $cleanNote);
    }

    // Parse event index from task ID
    $eventIndex = $this->parseEventIndex($taskId);
    if ($eventIndex === null) {
        throw new RuntimeException(__('Invalid task ID format.', 'wecoza-events'));
    }

    // Update event_dates JSONB at specific index
    $this->updateEventStatus($classId, $eventIndex, 'Completed', $userId, $timestamp, $cleanNote);

    // Return fresh tasks
    $class = $this->fetchClassById($classId);
    return $this->buildTasksFromEvents($class);
}
```

**2. Add completeAgentOrderTask() helper**

```php
private function completeAgentOrderTask(
    int $classId,
    int $userId,
    string $timestamp,
    ?string $note
): TaskCollection {
    $orderNumber = $this->normaliseOrderNumber($note ?? '');
    if ($orderNumber === '') {
        throw new RuntimeException(__('An order number is required before completing this task.', 'wecoza-events'));
    }

    $this->updateClassOrderNumber($classId, $orderNumber);

    // Return fresh tasks
    $class = $this->fetchClassById($classId);
    return $this->buildTasksFromEvents($class);
}
```

**3. Rewrite reopenTask()**

Change signature from `reopenTask(int $logId, ...)` to `reopenTask(int $classId, ...)`.

New implementation:
```php
public function reopenTask(int $classId, string $taskId): TaskCollection
{
    // Handle agent-order task specially - set order_nr to empty string
    if ($taskId === 'agent-order') {
        return $this->reopenAgentOrderTask($classId);
    }

    // Parse event index from task ID
    $eventIndex = $this->parseEventIndex($taskId);
    if ($eventIndex === null) {
        throw new RuntimeException(__('Invalid task ID format.', 'wecoza-events'));
    }

    // Update event_dates JSONB: set status to Pending, clear completion metadata, preserve notes
    $this->updateEventStatus($classId, $eventIndex, 'Pending', null, null, null);

    // Return fresh tasks
    $class = $this->fetchClassById($classId);
    return $this->buildTasksFromEvents($class);
}
```

**4. Add reopenAgentOrderTask() helper**

```php
private function reopenAgentOrderTask(int $classId): TaskCollection
{
    // Set order_nr to empty string = incomplete
    $this->updateClassOrderNumber($classId, '');

    // Return fresh tasks
    $class = $this->fetchClassById($classId);
    return $this->buildTasksFromEvents($class);
}
```

**5. Add fetchClassById() helper**

```php
private function fetchClassById(int $classId): array
{
    $sql = "SELECT class_id, order_nr, event_dates FROM classes WHERE class_id = :class_id LIMIT 1";

    $stmt = $this->db->getPdo()->prepare($sql);
    if ($stmt === false) {
        throw new RuntimeException('Failed to prepare class lookup.');
    }

    $stmt->bindValue(':class_id', $classId, PDO::PARAM_INT);
    if (!$stmt->execute()) {
        throw new RuntimeException('Failed to execute class lookup.');
    }

    $class = $stmt->fetch(PDO::FETCH_ASSOC);
    if ($class === false) {
        throw new RuntimeException(__('Class not found.', 'wecoza-events'));
    }

    return $class;
}
```

**6. Remove old log-based methods**

The old methods that reference class_change_logs table are now obsolete:
- Keep getTasksWithTemplate() for backward compatibility during transition (Phase 17 removes it)
- Keep getTasksForLog(), saveTasksForLog() for backward compatibility
- Keep fetchOperation(), fetchClassIdForLog(), getPreviousTasksSnapshot() for backward compatibility
  </action>
  <verify>
Run syntax check: `php -l src/Events/Services/TaskManager.php`
Run tests: `./vendor/bin/phpunit tests/Events/TaskManagementTest.php`
  </verify>
  <done>
TaskManager::markTaskCompleted() and reopenTask() use class_id, call updateEventStatus() for events, updateClassOrderNumber() for agent-order
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor TaskController to use class_id</name>
  <files>src/Events/Controllers/TaskController.php</files>
  <action>
Update handleUpdate() to accept class_id parameter instead of log_id.

Replace the parameter extraction and validation:

```php
public function handleUpdate(): void
{
    check_ajax_referer('wecoza_events_tasks', 'nonce');

    if (!is_user_logged_in()) {
        $this->responder->error(__('Please sign in to manage tasks.', 'wecoza-events'), 403);
    }

    // CHANGED: class_id instead of log_id
    $classId = $this->request->getPostInt('class_id') ?? 0;
    $taskId = $this->request->getPostString('task_id', '') ?? '';
    $taskAction = $this->request->getPostString('task_action', '') ?? '';

    if ($classId <= 0 || $taskId === '' || !in_array($taskAction, ['complete', 'reopen'], true)) {
        $this->responder->error(__('Invalid task request.', 'wecoza-events'), 400);
    }

    try {
        if ($taskAction === 'complete') {
            $note = $this->request->getPostString('note');
            $note = $note !== null ? trim($note) : null;
            // CHANGED: Pass classId, not logId
            $tasks = $this->manager->markTaskCompleted(
                $classId,
                $taskId,
                get_current_user_id(),
                current_time('mysql', true),
                $note
            );
        } else {
            // CHANGED: Pass classId, not logId
            $tasks = $this->manager->reopenTask($classId, $taskId);
        }
    } catch (Throwable $exception) {
        $this->responder->error($exception->getMessage(), 500);
    }

    $this->responder->success([
        'tasks' => $this->presenter->presentTasks($tasks),
    ]);
}
```

Note: The JavaScript code that calls this AJAX endpoint will need to be updated in Phase 16 to send class_id instead of log_id. For now, the PHP side is ready.
  </action>
  <verify>
Run syntax check: `php -l src/Events/Controllers/TaskController.php`
  </verify>
  <done>
TaskController::handleUpdate() extracts class_id (not log_id) and passes it to TaskManager methods
  </done>
</task>

<task type="auto">
  <name>Task 3: Update tests for class_id based methods</name>
  <files>tests/Events/TaskManagementTest.php</files>
  <action>
Update or add tests to verify the refactored TaskManager methods work correctly with class_id.

Add/update test methods:

1. **Test parseEventIndex()**
```php
public function testParseEventIndexReturnsIndexForValidEventId(): void
{
    $manager = new TaskManager();
    $reflection = new \ReflectionClass($manager);
    $method = $reflection->getMethod('parseEventIndex');
    $method->setAccessible(true);

    $this->assertSame(0, $method->invoke($manager, 'event-0'));
    $this->assertSame(3, $method->invoke($manager, 'event-3'));
    $this->assertSame(123, $method->invoke($manager, 'event-123'));
}

public function testParseEventIndexReturnsNullForNonEventId(): void
{
    $manager = new TaskManager();
    $reflection = new \ReflectionClass($manager);
    $method = $reflection->getMethod('parseEventIndex');
    $method->setAccessible(true);

    $this->assertNull($method->invoke($manager, 'agent-order'));
    $this->assertNull($method->invoke($manager, 'invalid'));
    $this->assertNull($method->invoke($manager, 'event-'));
}
```

2. **Verify Task::reopen() preserves notes**
```php
public function testReopenPreservesNotes(): void
{
    $task = new Task('test-1', 'Test Task', Task::STATUS_COMPLETED, 1, '2026-02-03', 'Important note');
    $reopened = $task->reopen();

    $this->assertSame(Task::STATUS_OPEN, $reopened->getStatus());
    $this->assertNull($reopened->getCompletedBy());
    $this->assertNull($reopened->getCompletedAt());
    $this->assertSame('Important note', $reopened->getNote()); // Note preserved!
}
```

3. If integration tests exist for task completion, update them to use class_id pattern.
  </action>
  <verify>
Run tests: `./vendor/bin/phpunit tests/Events/TaskManagementTest.php`
  </verify>
  <done>
All tests pass, including tests for parseEventIndex(), reopen notes preservation, and class_id based methods
  </done>
</task>

</tasks>

<verification>
1. PHP syntax check passes for TaskController.php and TaskManager.php
2. All TaskManagementTest tests pass
3. TaskController extracts 'class_id' not 'log_id': grep -n "class_id" src/Events/Controllers/TaskController.php
4. TaskManager::markTaskCompleted() first parameter is $classId: grep -n "markTaskCompleted" src/Events/Services/TaskManager.php
5. TaskManager calls updateEventStatus() for event tasks: grep -n "updateEventStatus" src/Events/Services/TaskManager.php
6. Task::reopen() preserves notes: grep -A5 "function reopen" src/Events/Models/Task.php (should NOT show note = null)
</verification>

<success_criteria>
1. TaskController accepts class_id POST parameter
2. TaskManager::markTaskCompleted($classId, ...) updates event_dates JSONB
3. TaskManager::markTaskCompleted handles agent-order specially (writes to order_nr)
4. TaskManager::reopenTask($classId, ...) sets event status to Pending, clears completed_by/completed_at
5. TaskManager::reopenTask handles agent-order specially (sets order_nr to empty string)
6. All tests pass (29+ tests)
</success_criteria>

<output>
After completion, create `.planning/phases/15-bidirectional-sync/15-02-SUMMARY.md`
</output>
