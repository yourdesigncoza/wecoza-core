---
phase: 10-architecture-type-safety
plan: 03
type: execute
wave: 2
depends_on: ["10-01", "10-02"]
files_modified:
  - src/Events/Services/AISummaryService.php
autonomous: true

must_haves:
  truths:
    - "generateSummary() delegates to focused single-purpose methods"
    - "obfuscateContext() handles all PII obfuscation logic"
    - "buildPromptMessages() constructs OpenAI message array"
    - "processApiResponse() handles success/failure response processing"
    - "Method returns SummaryResultDTO instead of array"
  artifacts:
    - path: "src/Events/Services/AISummaryService.php"
      provides: "Refactored AI summary service with SRP methods"
      contains: "private function obfuscateContext"
  key_links:
    - from: "AISummaryService::generateSummary"
      to: "obfuscateContext"
      via: "method delegation"
      pattern: "\\$this->obfuscateContext"
    - from: "AISummaryService::generateSummary"
      to: "processApiResponse"
      via: "method delegation"
      pattern: "\\$this->processApiResponse"
---

<objective>
Refactor generateSummary() to follow Single Responsibility Principle by extracting focused methods.

Purpose: Break the 110-line monolithic method into focused single-purpose methods that are easier to test, understand, and maintain. Uses DTOs from Plan 01 and Enums from Plan 02. This satisfies ARCH-01.

Output: Refactored AISummaryService.php with 4-5 extracted methods and DTO return types.
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-architecture-type-safety/10-RESEARCH.md

# Prior plan outputs (DTOs and Enums)
@.planning/phases/10-architecture-type-safety/10-01-SUMMARY.md
@.planning/phases/10-architecture-type-safety/10-02-SUMMARY.md

# Source file to refactor
@src/Events/Services/AISummaryService.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add imports and update normaliseRecord to use DTOs</name>
  <files>
    src/Events/Services/AISummaryService.php
  </files>
  <action>
**Step 1:** Add use statements for new DTOs and Enums at top of file (after existing use statements):

```php
use WeCoza\Events\DTOs\RecordDTO;
use WeCoza\Events\DTOs\EmailContextDTO;
use WeCoza\Events\DTOs\SummaryResultDTO;
use WeCoza\Events\DTOs\ObfuscatedDataDTO;
use WeCoza\Events\Enums\SummaryStatus;
```

**Step 2:** Update `normaliseRecord()` to return RecordDTO instead of array:

```php
private function normaliseRecord(?array $existing): RecordDTO
{
    return RecordDTO::fromArray($existing);
}
```

**Step 3:** Add a helper method to check if generation should be skipped:

```php
/**
 * Check if summary generation should be skipped
 */
private function shouldSkipGeneration(RecordDTO $record): bool
{
    return $record->status === SummaryStatus::SUCCESS->value
        || $record->attempts >= $this->maxAttempts;
}

/**
 * Build result for skipped generation (already success or max attempts)
 */
private function buildSkippedResult(RecordDTO $record): SummaryResultDTO
{
    $emailContext = EmailContextDTO::empty();

    if ($record->status === SummaryStatus::SUCCESS->value) {
        return SummaryResultDTO::success($record, $emailContext);
    }

    // Max attempts reached
    $record = $record->withStatus(SummaryStatus::FAILED->value);
    return SummaryResultDTO::failed($record, $emailContext);
}
```
  </action>
  <verify>
```bash
php -l src/Events/Services/AISummaryService.php
grep -q "use WeCoza\\\\Events\\\\DTOs\\\\RecordDTO" src/Events/Services/AISummaryService.php
grep -q "private function shouldSkipGeneration" src/Events/Services/AISummaryService.php
```
  </verify>
  <done>Import statements added, normaliseRecord returns RecordDTO, shouldSkipGeneration and buildSkippedResult helper methods created</done>
</task>

<task type="auto">
  <name>Task 2: Extract obfuscateContext and processApiResponse methods</name>
  <files>
    src/Events/Services/AISummaryService.php
  </files>
  <action>
**Step 1:** Extract the obfuscation logic (lines 89-101) into a focused method:

```php
/**
 * Obfuscate PII from context data
 *
 * @param array<string,mixed> $context Raw context with potential PII
 * @return ObfuscatedDataDTO Obfuscated payloads with alias mappings
 */
private function obfuscateContext(array $context): ObfuscatedDataDTO
{
    $state = null;

    $newRowResult = $this->obfuscatePayloadWithLabels(
        (array) ($context['new_row'] ?? []),
        $state
    );
    $state = $newRowResult['state'];

    $diffResult = $this->obfuscatePayloadWithLabels(
        (array) ($context['diff'] ?? []),
        $state
    );
    $state = $diffResult['state'];

    $oldRowResult = $this->obfuscatePayloadWithLabels(
        (array) ($context['old_row'] ?? []),
        $state
    );

    return ObfuscatedDataDTO::fromResults($newRowResult, $diffResult, $oldRowResult);
}
```

**Step 2:** Extract the API response processing (lines 128-178) into a focused method:

```php
/**
 * Process OpenAI API response and build result DTO
 *
 * @param array{success:bool,content:string,error_code:?string,error_message:?string,model:?string,tokens:int} $response
 * @param RecordDTO $record Current record state
 * @param ObfuscatedDataDTO $obfuscatedData Obfuscation results
 * @param int $elapsed Processing time in milliseconds
 * @return SummaryResultDTO
 */
private function processApiResponse(
    array $response,
    RecordDTO $record,
    ObfuscatedDataDTO $obfuscatedData,
    int $elapsed
): SummaryResultDTO {
    $emailContext = new EmailContextDTO(
        aliasMap: $obfuscatedData->aliases,
        fieldLabels: $obfuscatedData->fieldLabels,
        obfuscated: [
            'new_row' => $obfuscatedData->newRow,
            'diff' => $obfuscatedData->diff,
            'old_row' => $obfuscatedData->oldRow,
        ]
    );

    if ($response['success'] === true) {
        $summaryText = $this->normaliseSummaryText($response['content']);

        $record = $record
            ->withStatus(SummaryStatus::SUCCESS->value)
            ->withSummary($summaryText)
            ->withError(null, null)
            ->withGeneratedAt(gmdate('c'))
            ->withModel($response['model'])
            ->withTokensUsed($response['tokens'])
            ->withProcessingTimeMs($elapsed);

        $this->metrics['success']++;
        $this->metrics['total_tokens'] += $response['tokens'];

        return SummaryResultDTO::success($record, $emailContext);
    }

    // Handle failure
    $record = $record
        ->withError($response['error_code'], $response['error_message'])
        ->withModel($record->model ?? $response['model'])
        ->withProcessingTimeMs($elapsed);

    $newStatus = $record->attempts >= $this->maxAttempts
        ? SummaryStatus::FAILED->value
        : SummaryStatus::PENDING->value;

    $record = $record->withStatus($newStatus);

    if ($newStatus === SummaryStatus::FAILED->value) {
        $this->metrics['failed']++;
        return SummaryResultDTO::failed($record, $emailContext);
    }

    return SummaryResultDTO::pending($record, $emailContext);
}
```

**Note:** The RecordDTO needs additional with* methods. Add these to RecordDTO if not already present:
- withGeneratedAt(string): self
- withModel(?string): self
- withTokensUsed(int): self
- withProcessingTimeMs(int): self
  </action>
  <verify>
```bash
php -l src/Events/Services/AISummaryService.php
grep -q "private function obfuscateContext" src/Events/Services/AISummaryService.php
grep -q "private function processApiResponse" src/Events/Services/AISummaryService.php
```
  </verify>
  <done>obfuscateContext and processApiResponse methods extracted with proper type hints and DTO usage</done>
</task>

<task type="auto">
  <name>Task 3: Refactor generateSummary to use extracted methods</name>
  <files>
    src/Events/Services/AISummaryService.php
    src/Events/DTOs/RecordDTO.php
  </files>
  <action>
**Step 1:** First, ensure RecordDTO has all required with* methods. Update RecordDTO to add any missing ones:

```php
public function withGeneratedAt(?string $generatedAt): self
{
    return new self(
        $this->summary,
        $this->status,
        $this->errorCode,
        $this->errorMessage,
        $this->attempts,
        $this->viewed,
        $this->viewedAt,
        $generatedAt,
        $this->model,
        $this->tokensUsed,
        $this->processingTimeMs
    );
}

public function withModel(?string $model): self { /* similar pattern */ }
public function withTokensUsed(int $tokensUsed): self { /* similar pattern */ }
public function withProcessingTimeMs(int $processingTimeMs): self { /* similar pattern */ }
```

**Step 2:** Refactor generateSummary() to the new clean structure:

```php
/**
 * Generate AI summary for class change notification
 *
 * @param array<string,mixed> $context Change context (new_row, diff, old_row, operation, etc.)
 * @param array<string,mixed>|null $existing Existing record if retrying
 * @return SummaryResultDTO
 */
public function generateSummary(array $context, ?array $existing = null): SummaryResultDTO
{
    $record = $this->normaliseRecord($existing);

    // Early exit for already-complete or max-attempts records
    if ($this->shouldSkipGeneration($record)) {
        return $this->buildSkippedResult($record);
    }

    // Obfuscate PII from context
    $obfuscatedData = $this->obfuscateContext($context);

    // Prepare for API call
    $attemptNumber = $record->attempts + 1;
    $delaySeconds = $this->backoffDelaySeconds($record->attempts);
    if ($delaySeconds > 0) {
        usleep($delaySeconds * 1_000_000);
    }

    // Build prompt messages
    $messages = $this->buildMessages(
        (string) ($context['operation'] ?? ''),
        $context,
        $obfuscatedData->newRow,
        $obfuscatedData->diff,
        $obfuscatedData->oldRow
    );

    // Call OpenAI
    $start = microtime(true);
    $response = $this->callOpenAI($messages, self::MODEL);
    $elapsed = (int) round((microtime(true) - $start) * 1000);

    // Update record with attempt info
    $record = $record
        ->incrementAttempts()
        ->withProcessingTimeMs($elapsed);

    $this->metrics['attempts']++;
    $this->metrics['processing_time_ms'] += $elapsed;

    // Process response and return result
    return $this->processApiResponse($response, $record, $obfuscatedData, $elapsed);
}
```

**Step 3:** Add backward compatibility method for code that expects array return:

```php
/**
 * Generate summary returning array format (backward compatibility)
 *
 * @deprecated Use generateSummary() which returns SummaryResultDTO
 */
public function generateSummaryArray(array $context, ?array $existing = null): array
{
    return $this->generateSummary($context, $existing)->toArray();
}
```

**Step 4:** Run tests to verify refactoring didn't break functionality:
```bash
./vendor/bin/phpunit tests/Events/AISummarizationTest.php
```
  </action>
  <verify>
```bash
php -l src/Events/Services/AISummaryService.php
php -l src/Events/DTOs/RecordDTO.php

# Run existing tests
./vendor/bin/phpunit tests/Events/AISummarizationTest.php --no-coverage

# Verify method exists and returns DTO type
grep -q "public function generateSummary.*SummaryResultDTO" src/Events/Services/AISummaryService.php
```
  </verify>
  <done>generateSummary() refactored to use extracted methods, returns SummaryResultDTO, backward compatibility method added, tests pass</done>
</task>

</tasks>

<verification>
All phase 10 plan 03 checks:
- [ ] generateSummary() is now ~30 lines instead of ~110
- [ ] obfuscateContext() handles all PII obfuscation
- [ ] processApiResponse() handles success/failure logic
- [ ] shouldSkipGeneration() checks early exit conditions
- [ ] buildSkippedResult() handles already-complete cases
- [ ] Method returns SummaryResultDTO not array
- [ ] SummaryStatus enum used instead of string literals
- [ ] Existing tests still pass
- [ ] File passes PHP syntax check
</verification>

<success_criteria>
- generateSummary() reduced from ~110 lines to ~30 lines
- Four private methods extracted (obfuscateContext, processApiResponse, shouldSkipGeneration, buildSkippedResult)
- Method signature returns SummaryResultDTO
- SummaryStatus enum used for status values
- RecordDTO used throughout instead of arrays
- All existing AISummarizationTest tests pass
- Backward compatibility method available for callers expecting arrays
</success_criteria>

<output>
After completion, create `.planning/phases/10-architecture-type-safety/10-03-SUMMARY.md`

Also update `.planning/REQUIREMENTS.md`:
- Mark ARCH-01 as complete
- Mark ARCH-02 as complete (already implemented - verified in BaseRepository)
- Mark QUAL-02 as complete
- Mark QUAL-03 as complete
</output>
