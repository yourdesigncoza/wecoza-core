---
phase: 02-database-migration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - schema/migrations/001-verify-triggers.sql
  - schema/migrations/README.md
autonomous: true

must_haves:
  truths:
    - "class_change_logs table captures INSERT events on public.classes"
    - "class_change_logs table captures UPDATE events on public.classes"
    - "Trigger functions execute without errors when classes table is modified"
    - "Migration is documented for future reference"
  artifacts:
    - path: "schema/migrations/001-verify-triggers.sql"
      provides: "Trigger verification and idempotent recreation script"
      contains: "CREATE OR REPLACE"
    - path: "schema/migrations/README.md"
      provides: "Migration documentation"
      contains: "class_change_logs"
  key_links:
    - from: "public.log_class_change()"
      to: "public.class_change_logs"
      via: "INSERT INTO statement"
      pattern: "INSERT INTO.*class_change_logs"
    - from: "classes_log_insert_update trigger"
      to: "public.log_class_change()"
      via: "EXECUTE FUNCTION"
      pattern: "EXECUTE FUNCTION.*log_class_change"
---

<objective>
Verify and document PostgreSQL triggers for class change logging, ensuring they operate correctly with wecoza-core.

Purpose: The triggers and functions already exist in the public schema (verified in schema backup). This plan verifies they work correctly, creates idempotent migration scripts for reproducibility, and documents the trigger infrastructure.

Output: Migration script that can verify/recreate triggers idempotently, README documenting trigger behavior, verified that INSERT/UPDATE on classes populates class_change_logs.
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-database-migration/02-RESEARCH.md

# Reference: existing schema with trigger definitions
@schema/wecoza_db_schema_bu_jan_29.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create idempotent trigger migration script</name>
  <files>schema/migrations/001-verify-triggers.sql</files>
  <action>
Create the `schema/migrations/` directory if it doesn't exist.

Create `001-verify-triggers.sql` with idempotent trigger/function definitions:

```sql
-- Migration: 001-verify-triggers.sql
-- Purpose: Ensure class change logging triggers exist and function correctly
-- Idempotent: Safe to run multiple times (uses CREATE OR REPLACE)
-- Date: 2026-02-02

BEGIN;

-- Set search_path for consistent schema resolution
SET search_path TO public;

-- =============================================================================
-- FUNCTION: log_class_change()
-- Logs INSERT and UPDATE operations on classes table to class_change_logs
-- Computes JSONB diff for UPDATE operations
-- Sends pg_notify for real-time listeners
-- =============================================================================
CREATE OR REPLACE FUNCTION public.log_class_change() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    op TEXT := TG_OP;
    event_time TIMESTAMP WITHOUT TIME ZONE := NOW();
    new_data JSONB := to_jsonb(NEW);
    old_data JSONB := CASE WHEN TG_OP = 'UPDATE' THEN to_jsonb(OLD) ELSE NULL END;
    diff JSONB := '{}'::jsonb;
BEGIN
    IF op = 'UPDATE' THEN
        diff := (
            SELECT COALESCE(
                jsonb_object_agg(key, jsonb_build_object('old', old_data -> key, 'new', new_data -> key)),
                '{}'::jsonb
            )
            FROM (
                SELECT key FROM jsonb_object_keys(new_data) AS new_keys(key)
                UNION
                SELECT key FROM jsonb_object_keys(COALESCE(old_data, '{}'::jsonb)) AS old_keys(key)
            ) AS keys(key)
            WHERE (old_data -> key) IS DISTINCT FROM (new_data -> key)
        );
    ELSE
        diff := new_data;
    END IF;

    INSERT INTO public.class_change_logs (class_id, operation, changed_at, new_row, old_row, diff)
    VALUES (NEW.class_id, op, event_time, new_data, old_data, diff);

    PERFORM pg_notify(
        'class_change_channel',
        json_build_object(
            'operation', op,
            'class_id', NEW.class_id,
            'class_code', NEW.class_code,
            'class_subject', NEW.class_subject,
            'changed_at', event_time,
            'diff', diff
        )::text
    );

    RETURN NEW;
END;
$$;

COMMENT ON FUNCTION public.log_class_change() IS
'Trigger function that logs class INSERT/UPDATE to class_change_logs with JSONB diff calculation';

-- =============================================================================
-- TRIGGER: classes_log_insert_update
-- Fires AFTER INSERT OR UPDATE on public.classes
-- =============================================================================
CREATE OR REPLACE TRIGGER classes_log_insert_update
    AFTER INSERT OR UPDATE ON public.classes
    FOR EACH ROW
    EXECUTE FUNCTION public.log_class_change();

-- =============================================================================
-- FUNCTION: update_updated_at_column()
-- Generic trigger function to auto-update updated_at timestamp
-- =============================================================================
CREATE OR REPLACE FUNCTION public.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;

COMMENT ON FUNCTION public.update_updated_at_column() IS
'Generic trigger function to auto-update updated_at column on UPDATE';

-- =============================================================================
-- VERIFICATION: Confirm triggers exist
-- =============================================================================
DO $$
DECLARE
    trigger_count INT;
    function_count INT;
BEGIN
    -- Check trigger exists
    SELECT COUNT(*) INTO trigger_count
    FROM pg_trigger t
    JOIN pg_class c ON t.tgrelid = c.oid
    JOIN pg_namespace n ON c.relnamespace = n.oid
    WHERE t.tgname = 'classes_log_insert_update'
      AND c.relname = 'classes'
      AND n.nspname = 'public';

    IF trigger_count = 0 THEN
        RAISE EXCEPTION 'Migration verification failed: classes_log_insert_update trigger not found on public.classes';
    END IF;

    -- Check function exists
    SELECT COUNT(*) INTO function_count
    FROM pg_proc p
    JOIN pg_namespace n ON p.pronamespace = n.oid
    WHERE p.proname = 'log_class_change'
      AND n.nspname = 'public';

    IF function_count = 0 THEN
        RAISE EXCEPTION 'Migration verification failed: public.log_class_change() function not found';
    END IF;

    RAISE NOTICE 'Migration verification successful: trigger and function exist';
END $$;

COMMIT;
```

WHY: Idempotent script ensures triggers can be verified/recreated safely. Using CREATE OR REPLACE means running this multiple times is safe and won't error on existing objects.
  </action>
  <verify>
1. File exists: `ls -la schema/migrations/001-verify-triggers.sql`
2. Contains CREATE OR REPLACE: `grep -c "CREATE OR REPLACE" schema/migrations/001-verify-triggers.sql` should return >= 3
  </verify>
  <done>Idempotent migration script exists at schema/migrations/001-verify-triggers.sql with trigger/function definitions</done>
</task>

<task type="auto">
  <name>Task 2: Create migration README documentation</name>
  <files>schema/migrations/README.md</files>
  <action>
Create `schema/migrations/README.md` documenting the trigger infrastructure:

```markdown
# Database Migrations

This directory contains SQL migration scripts for wecoza-core database schema.

## Migration Files

| File | Purpose | Idempotent |
|------|---------|------------|
| 001-verify-triggers.sql | Class change logging triggers | Yes |

## Trigger Infrastructure

### class_change_logs Trigger

The `classes_log_insert_update` trigger automatically logs all INSERT and UPDATE operations on the `public.classes` table.

**Trigger:** `classes_log_insert_update`
- **Table:** `public.classes`
- **Events:** AFTER INSERT OR UPDATE
- **Function:** `public.log_class_change()`

**Function:** `public.log_class_change()`
- Converts row data to JSONB
- Computes diff for UPDATE operations (only changed fields)
- Inserts record into `public.class_change_logs`
- Sends pg_notify to `class_change_channel` for real-time listeners

**Table:** `public.class_change_logs`
| Column | Type | Description |
|--------|------|-------------|
| log_id | BIGSERIAL | Primary key |
| class_id | INTEGER | FK to classes.class_id |
| operation | TEXT | 'INSERT' or 'UPDATE' |
| changed_at | TIMESTAMP | When change occurred |
| new_row | JSONB | Full row data after change |
| old_row | JSONB | Full row data before change (UPDATE only) |
| diff | JSONB | Only changed fields with old/new values |

### Running Migrations

Migrations are idempotent and can be run multiple times safely:

```bash
# Connect to database and run migration
psql -h localhost -U John -d wecoza -f schema/migrations/001-verify-triggers.sql
```

### Verifying Triggers

Check trigger exists:
```sql
SELECT tgname, tgrelid::regclass, tgfoid::regproc
FROM pg_trigger
WHERE tgname = 'classes_log_insert_update';
```

Test trigger fires on INSERT:
```sql
-- Insert test class
INSERT INTO public.classes (class_code, class_subject, original_start_date)
VALUES ('TEST-MIGRATION', 'Test Subject', '2026-12-01')
RETURNING class_id;

-- Verify log entry created
SELECT * FROM public.class_change_logs
WHERE (new_row->>'class_code') = 'TEST-MIGRATION'
ORDER BY changed_at DESC LIMIT 1;

-- Cleanup test data
DELETE FROM public.class_change_logs WHERE (new_row->>'class_code') = 'TEST-MIGRATION';
DELETE FROM public.classes WHERE class_code = 'TEST-MIGRATION';
```

## Notes

- All migrations use `CREATE OR REPLACE` for idempotency
- Migrations are wrapped in transactions (BEGIN/COMMIT)
- Verification checks run at end of each migration
- pg_notify has 8000 byte payload limit - large diffs may be truncated
```

WHY: Documentation ensures future developers understand trigger infrastructure and can verify/troubleshoot issues.
  </action>
  <verify>
1. File exists: `ls -la schema/migrations/README.md`
2. Contains key sections: `grep -c "class_change_logs" schema/migrations/README.md` should return >= 3
  </verify>
  <done>Migration README exists with trigger documentation and verification instructions</done>
</task>

<task type="auto">
  <name>Task 3: Verify trigger functionality with test INSERT</name>
  <files>N/A (database verification)</files>
  <action>
Use WP-CLI to verify trigger fires correctly on INSERT.

Run the following verification steps via WP-CLI database command:

1. First, check if trigger exists:
```bash
wp eval "
\$db = wecoza_db();
\$pdo = \$db->getPdo();

// Check trigger exists
\$sql = \"SELECT tgname FROM pg_trigger t
         JOIN pg_class c ON t.tgrelid = c.oid
         WHERE t.tgname = 'classes_log_insert_update' AND c.relname = 'classes'\";
\$result = \$pdo->query(\$sql)->fetch();
echo 'Trigger exists: ' . (\$result ? 'YES' : 'NO') . PHP_EOL;

// Get latest log count
\$countSql = 'SELECT COUNT(*) FROM class_change_logs';
\$count = \$pdo->query(\$countSql)->fetchColumn();
echo 'Current log entries: ' . \$count . PHP_EOL;
"
```

2. If trigger exists, the class_change_logs table should have entries from previous INSERT/UPDATE operations on classes.

3. Document the verification results.

WHY: Confirms trigger infrastructure works in production environment without making test data changes.
  </action>
  <verify>
Run WP-CLI command above. Expected output:
- "Trigger exists: YES"
- "Current log entries: [some number >= 0]"

Alternative verification via psql if wp eval not available:
```bash
psql -h localhost -U John -d wecoza -c "SELECT tgname FROM pg_trigger t JOIN pg_class c ON t.tgrelid = c.oid WHERE t.tgname = 'classes_log_insert_update' AND c.relname = 'classes';"
```
  </verify>
  <done>Trigger exists and is attached to classes table, ready for INSERT/UPDATE logging</done>
</task>

</tasks>

<verification>
1. `schema/migrations/` directory exists with 001-verify-triggers.sql and README.md
2. Migration script contains idempotent CREATE OR REPLACE statements
3. README documents trigger infrastructure and verification steps
4. Trigger `classes_log_insert_update` exists on `public.classes` table
5. Function `public.log_class_change()` exists in database
</verification>

<success_criteria>
- schema/migrations/001-verify-triggers.sql exists with idempotent trigger definitions
- schema/migrations/README.md exists with trigger documentation
- Trigger classes_log_insert_update confirmed to exist on public.classes
- Function log_class_change() confirmed to exist in public schema
- class_change_logs table ready to capture INSERT/UPDATE events
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-migration/02-02-SUMMARY.md`
</output>
