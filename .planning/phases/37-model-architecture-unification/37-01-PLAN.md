---
phase: 37-model-architecture-unification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/Clients/Models/ClientsModel.php
autonomous: true

must_haves:
  truths:
    - "ClientsModel class declaration reads 'class ClientsModel extends BaseModel'"
    - "ClientsModel has no duplicate get/set/toArray methods — only BaseModel defines them"
    - "ClientService and all AJAX handlers work unchanged (getAll, getById, validate, create, update, delete)"
    - "ClientsModel::validate() uses consistent validation pattern aligned with BaseModel architecture"
  artifacts:
    - path: "src/Clients/Models/ClientsModel.php"
      provides: "ClientsModel extending BaseModel with preserved column-resolution and business logic"
      contains: "class ClientsModel extends BaseModel"
  key_links:
    - from: "src/Clients/Services/ClientService.php"
      to: "src/Clients/Models/ClientsModel.php"
      via: "new ClientsModel() constructor and method calls"
      pattern: "->getAll\\(|->getById\\(|->validate\\(|->create\\(|->update\\(|->delete\\("
    - from: "src/Clients/Controllers/LocationsController.php"
      to: "src/Clients/Models/ClientsModel.php"
      via: "getModel()->validate() and getModel()->getById()"
      pattern: "->validate\\(|->getById\\("
---

<objective>
Migrate ClientsModel to extend BaseModel while preserving its unique column-resolution mechanism, relationship loading, and all public method signatures.

Purpose: Eliminate architectural inconsistency where ClientsModel is a standalone class duplicating BaseModel patterns. After migration, ClientsModel inherits BaseModel's hydration, type casting, and property access infrastructure while retaining its specialized column-resolution and relationship loading.

Output: Refactored ClientsModel.php extending BaseModel with zero changes to consumer code.
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@core/Abstract/BaseModel.php
@src/Clients/Models/ClientsModel.php
@src/Clients/Services/ClientService.php
@src/Learners/Models/LearnerModel.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate ClientsModel to extend BaseModel</name>
  <files>src/Clients/Models/ClientsModel.php</files>
  <action>
Refactor ClientsModel to extend BaseModel. This is a CAREFUL refactor because ClientsModel has a unique architecture:

1. **Add BaseModel extension and use statement:**
   - Add `use WeCoza\Core\Abstract\BaseModel;`
   - Change class declaration to `class ClientsModel extends BaseModel`

2. **Convert instance properties to static (BaseModel convention):**
   - Change `protected string $table = 'clients'` to `protected static string $table = 'clients'`
   - Change `protected string $primaryKey = 'id'` to `protected static string $primaryKey = 'id'`
   - Change `protected $fillable = [...]` to `protected static array $fillable = [...]`
   - Add `protected static array $guarded = ['id', 'created_at', 'updated_at'];`
   - Add `protected static array $casts = [];` (no casting needed for this array-based model)

3. **Override BaseModel constructor to preserve column-resolution:**
   - ClientsModel's constructor does critical work: resolving column candidates, filtering fillable/json/date fields, instantiating related models.
   - Override constructor: call parent::__construct() first (with empty array), then do all column-resolution logic.
   - BaseModel's constructor accepts `array|object $data = []` and calls hydrate(). Since ClientsModel doesn't use property-based hydration (it uses array-based data patterns), pass empty array to parent.

4. **Preserve ALL existing public methods unchanged:**
   - `getAll($params)` - keep as-is (returns array, uses SQL directly)
   - `getById(int $id): array|null` - NOTE: BaseModel declares this abstract with return `?static`. ClientsModel returns `array|null`. Override the return type to `array|null` since PHP allows covariant return types (null is compatible). Actually, BaseModel's abstract method returns `?static` which is not compatible with `array|null`. **Resolution:** Change ClientsModel::getById to return `static|null` wrapper around the data, OR keep returning `array|null` and suppress the type mismatch by matching the parent signature but internally returning the array. The simplest approach: make getById return `?static` to match the abstract, but since ClientsModel consumers expect an array, add a separate `getByIdAsArray(int $id): ?array` method AND have getById return a model instance. HOWEVER, this would break consumers. **Best approach:** Override getById with `array|null` return — PHP 8 allows widening return types in some contexts. If not, keep the method but don't declare it as satisfying the abstract. Actually, the abstract says `?static`. We need to satisfy it. The cleanest solution:
     - Implement `getById(int $id): ?static` that returns a new static() instance hydrated with data (for BaseModel contract compliance)
     - Keep the existing array-returning logic available through the same method by having the static method return null when not found, or the model instance
     - BUT consumers call `ClientsModel::getById($id)` and expect an array. This is used in ClientService::getClient(), ClientService::getExportData(), and validate().
     - **FINAL DECISION:** Since BaseModel::getById is abstract and requires `?static`, we MUST implement it. But the existing ClientsModel::getById returns `array|null`. The safest approach:
       a. Rename existing `getById` logic to a private method `findByIdArray(int $id): ?array`
       b. Implement abstract `getById(int $id): ?static` that calls findByIdArray and wraps result
       c. Add a compatibility method `getByIdArray(int $id): ?array` that returns the raw array (this is what consumers actually need)
       d. BUT we need to NOT break consumers. All consumers call `ClientsModel::getById($id)` expecting array.

     **PRAGMATIC DECISION:** Do NOT try to make getById return a model instance. Instead, since BaseModel's abstract methods (getById, save, update, delete) are designed for a property-based model pattern that ClientsModel doesn't follow, implement them as thin wrappers:
     - `getById(int $id): ?static` — create a new static(), set internal data, return it. Consumers that call it statically and expect array will still work IF we also keep the array-returning behavior. This is impossible to do in one method.

     **SIMPLEST CORRECT APPROACH:** BaseModel has 4 abstract methods: getById, save, update, delete. ClientsModel already has implementations of all 4, but with different signatures. To satisfy the abstract contract:
     - `save(): bool` — already exists, returns false (documented as "use create() instead"). Keep as-is.
     - `update($id = null, array $data = []): bool` — already exists, compatible.
     - `delete($id = null): bool` — already exists, compatible.
     - `getById(int $id): ?static` — this is the problem. Current returns `array|null`.

     **FINAL APPROACH:** Change `getById` signature to return `?static` to match parent. Internally, build a new static() and populate its data. BUT consumers expect array. So:
     - Keep existing `getById` implementation as a **new public static method `findById(int $id): ?array`**
     - Implement `getById(int $id): ?static` as the BaseModel contract requires
     - Update consumers (ClientService, etc.) to call `findById()` instead of `getById()`

     WAIT — the planning context says "All existing model consumers (controllers, repositories, views) work unchanged". We cannot rename methods consumers use.

     **ABSOLUTE FINAL APPROACH:** Since the goal is architectural alignment, not perfect adherence to BaseModel's abstract contract, and since ClientsModel is fundamentally an array-oriented model that contains its own SQL (acting as model+repository hybrid):
     - Override `getById` to match the abstract signature `?static` BUT keep internal array logic
     - The method returns a `static` instance that wraps the array data
     - Add a `__toArray()` behavior so the result can be used as array (via ArrayAccess or keeping return as array)

     Actually the REAL simplest approach: **Don't make the abstract methods a problem.** Looking at BaseModel again — `getById`, `save`, `update`, `delete` are abstract. ClientsModel already has `save(): bool`, `update(): bool`, `delete(): bool` with compatible (or wider) signatures. For `getById` — change its return type from `array|null` to `?static` and have it return a static instance. Then update consumers to handle model instances OR arrays.

     This is getting too complex for one task. Let me simplify:

     **THE ACTUAL IMPLEMENTATION PLAN (simplified):**

     Since ClientsModel is a hybrid model+repository that returns arrays (not model instances), and consumers depend on array returns, the pragmatic approach is:

     a. Extend BaseModel for the infrastructure (constructor pattern, table/primaryKey statics, fillable/guarded)
     b. For the 4 abstract methods, implement them as thin wrappers that satisfy the contract:
        - `getById(int $id): ?static` — Return `null` always (placeholder, not used by consumers directly since the static method is already overridden)
        - Actually, PHP requires we match the signature. Current `getById` is `public static function getById(int $id): array|null`. To match `abstract public static function getById(int $id): ?static` we MUST return `?static`.

     **REAL PLAN:** The abstract signatures ARE the constraint. We have two options:
     1. Change ClientsModel::getById return type to `?static` — breaks consumers expecting array
     2. Don't extend BaseModel but only use a trait — not what the requirement says

     **Option 1 with migration:** Change getById to return `?static`. Consumers that call it will get a model instance. They currently access it as `$client['field_name']`. We can implement ArrayAccess on the wrapper so `$client['field_name']` still works. BUT BaseModel doesn't implement ArrayAccess.

     **CLEANEST IMPLEMENTATION:**
     1. Change `getById` to return `?static`, wrapping the array data into the model
     2. Implement `ArrayAccess` interface on ClientsModel so consumers can still use `$result['key']` syntax
     3. This makes the transition transparent — `$client = ClientsModel::getById(5)` returns a model that supports both `$client->key` AND `$client['key']`

     Implementing ArrayAccess is 4 simple methods. This preserves backward compatibility.

     Actually, re-reading BaseModel — it already has `__get` magic method for property access. The issue is consumers use array syntax `$client['field']`. Adding ArrayAccess to ClientsModel solves this.

     BUT WAIT — looking at the actual consumer code in ClientService more carefully: `$this->model->getById($clientId)` — the `$this->model` is an INSTANCE, not static call. And `getById` in ClientsModel is `public static function getById(int $id): array|null`. It can be called on an instance too. The consumer then uses the result as an array: `$client['main_client_id']`, `$client['id']`, etc.

     **THE IMPLEMENTATION (for real this time):**

     Since changing getById's return would cascade into many consumers, and the goal says "All existing model consumers work unchanged", the most pragmatic approach:

     - Don't extend BaseModel's abstract contract. Instead, have ClientsModel extend BaseModel but override ALL abstract methods with compatible implementations.
     - PHP 8 DOES allow covariant return types. `?static` in parent, `array|null` in child — this is NOT covariant (array is not a subtype of static). So this won't work.
     - The ONLY clean solution: modify the parent abstract or don't use abstract methods.

     **FINAL PRAGMATIC DECISION:** Remove `abstract` from BaseModel's getById/save/update/delete methods — make them concrete with default implementations (returning null/false). This way child classes override them but aren't forced into specific return types. BUT this changes BaseModel which affects LearnerModel and other existing models.

     **ACTUALLY THE SIMPLEST THING:** Looking at existing code — LearnerModel extends BaseModel and DOES match the signatures. ClassModel extends BaseModel too. So the abstract signatures work for property-based models. For ClientsModel (array-based), we need a different approach.

     **THE REAL FINAL ANSWER:**

     Given the constraints (consumers expect arrays, BaseModel expects ?static), the correct implementation for Phase 37 is:

     1. ClientsModel extends BaseModel
     2. Implement `getById(int $id): ?static` — internally do the SQL query, then hydrate a new static() model with the result array, return the model
     3. **Store the raw array data inside the model** so it can be returned via toArray() or accessed via ArrayAccess
     4. Implement `ArrayAccess` on ClientsModel so `$model['key']` still works
     5. This means consumers get a model back but can still do `$result['field']` — backward compatible

     This is the clean, correct approach. The model wraps the data, consumers use ArrayAccess for array-style access.

     **SPECIFIC IMPLEMENTATION STEPS:**

     a. Add `use WeCoza\Core\Abstract\BaseModel;` and `implements \ArrayAccess`
     b. Change class to `class ClientsModel extends BaseModel implements \ArrayAccess`
     c. Add ArrayAccess methods that delegate to the internal data (store query results in a protected `$attributes` array):
        ```php
        protected array $attributes = [];

        public function offsetExists(mixed $offset): bool { return isset($this->attributes[$offset]); }
        public function offsetGet(mixed $offset): mixed { return $this->attributes[$offset] ?? null; }
        public function offsetSet(mixed $offset, mixed $value): void { $this->attributes[$offset] = $value; }
        public function offsetUnset(mixed $offset): void { unset($this->attributes[$offset]); }
        ```
     d. Override constructor to call `parent::__construct([])` then do column resolution
     e. Change `getById(int $id): ?static` — do the existing SQL, then `$instance->attributes = $normalized; return $instance;`
     f. Keep `save(): bool`, `update(): bool`, `delete(): bool` — signatures already match
     g. Make `toArray(): array` return `$this->attributes` (overrides BaseModel's property-based toArray)
     h. Preserve ALL other public methods exactly as-is

     **IMPORTANT GOTCHA:** The existing getById does `$instance->hydrateRows($normalized)` which modifies the array by reference (adds related data like sites, communications). This must continue to work. The hydrated array gets stored in `$attributes`.

     **CONSUMER IMPACT CHECK:** After this change:
     - `ClientService` calls `$this->model->getById($id)` — gets a model instance implementing ArrayAccess. Code like `$client['field']` still works.
     - `ClientService` calls `$this->model->validate($data, $id)` — unchanged, validate takes array params.
     - `ClientService` calls `$this->model->getAll($params)` — unchanged, returns array of arrays.
     - `ClientService` calls `$this->model->create($data)` — unchanged, returns int|false.
     - All array-access patterns like `$client['main_client_id']` work via ArrayAccess.
  </action>
  <verify>
Run `php -l src/Clients/Models/ClientsModel.php` to verify no syntax errors.
Run `grep -n "extends BaseModel" src/Clients/Models/ClientsModel.php` to confirm extension.
Run `grep -n "implements.*ArrayAccess" src/Clients/Models/ClientsModel.php` to confirm ArrayAccess.
Run `grep -c "abstract" core/Abstract/BaseModel.php` to confirm BaseModel unchanged.
  </verify>
  <done>
ClientsModel extends BaseModel, implements ArrayAccess for backward-compatible array syntax. getById returns ?static (satisfying abstract contract). All public methods preserved. No changes to consumer code (ClientService, LocationsController, ClientAjaxHandlers).
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify ClientsModel consumers work unchanged</name>
  <files>src/Clients/Services/ClientService.php</files>
  <action>
After Task 1 refactors ClientsModel, verify that all consumer code compiles and integrates correctly:

1. **Syntax-check all consumer files:**
   - `php -l src/Clients/Services/ClientService.php`
   - `php -l src/Clients/Controllers/LocationsController.php`
   - `php -l src/Clients/Ajax/ClientAjaxHandlers.php` (if exists)
   - `php -l src/Clients/Repositories/ClientRepository.php`

2. **Verify no method signature mismatches:**
   - Grep for all calls to ClientsModel methods across the Clients module
   - Confirm each call site is compatible with the new signatures
   - Specifically check: getById returns are used with array syntax `['key']` — ArrayAccess handles this
   - Check: validate() still accepts `($data, $id)` — should be unchanged
   - Check: getAll() still returns array of arrays — unchanged
   - Check: create() still returns int|false — unchanged

3. **If any incompatibilities found, make MINIMAL adjustments:**
   - Only change consumer code if absolutely necessary
   - Prefer adapter methods in ClientsModel over changing consumers
   - Document any changes made

4. **Run full PHP syntax check on all modified/related files:**
   ```bash
   find src/Clients/ -name "*.php" -exec php -l {} \;
   ```
  </action>
  <verify>
All PHP files in src/Clients/ pass `php -l` syntax check.
`grep -rn "ClientsModel" src/Clients/ --include="*.php"` shows all usages — verify none are broken.
  </verify>
  <done>
All ClientsModel consumers (ClientService, LocationsController, ClientAjaxHandlers, ClientRepository) work unchanged with the refactored model. PHP lint passes on all files.
  </done>
</task>

</tasks>

<verification>
1. `php -l src/Clients/Models/ClientsModel.php` — no syntax errors
2. `grep "class ClientsModel extends BaseModel" src/Clients/Models/ClientsModel.php` — confirms extension
3. `grep "implements.*ArrayAccess" src/Clients/Models/ClientsModel.php` — confirms backward compatibility
4. All PHP files in `src/Clients/` pass syntax check
5. No changes to BaseModel.php (other models unaffected)
6. ClientService methods (handleClientSubmission, getClient, getClients, exportClientData) all work unchanged
</verification>

<success_criteria>
- ClientsModel class declaration reads `class ClientsModel extends BaseModel implements \ArrayAccess`
- BaseModel's abstract methods (getById, save, update, delete) all satisfied
- All array-access patterns ($client['field']) still work via ArrayAccess interface
- Zero changes needed in ClientService, LocationsController, or any AJAX handlers
- PHP lint passes on all files in src/Clients/
</success_criteria>

<output>
After completion, create `.planning/phases/37-model-architecture-unification/37-01-SUMMARY.md`
</output>
