---
phase: 18-notification-system
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/Events/Services/EventDispatcher.php
autonomous: true

must_haves:
  truths:
    - "EventDispatcher can create events from class and learner changes"
    - "Events are dispatched to Action Scheduler for async processing"
    - "Dispatcher captures full before/after state and diff"
  artifacts:
    - path: "src/Events/Services/EventDispatcher.php"
      provides: "Service for dispatching application-level events"
      exports: ["EventDispatcher"]
  key_links:
    - from: "src/Events/Services/EventDispatcher.php"
      to: "Action Scheduler"
      via: "as_enqueue_async_action"
      pattern: "as_enqueue_async_action"
---

<objective>
Create the EventDispatcher service that captures application events and schedules them for async notification processing.

Purpose: Bridge between controller actions (class create/update, learner changes) and the notification pipeline. Decouples event capture from notification sending.

Output: EventDispatcher service that can be called from controllers.
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/Events/Services/NotificationProcessor.php (reference for Action Scheduler usage)
@src/Events/Enums/EventType.php (from 18-01)
@src/Events/DTOs/ClassEventDTO.php (from 18-01)
@src/Events/Repositories/ClassEventRepository.php (from 18-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EventDispatcher service</name>
  <files>src/Events/Services/EventDispatcher.php</files>
  <action>
Create EventDispatcher service (src/Events/Services/EventDispatcher.php):

```php
namespace WeCoza\Events\Services;

use WeCoza\Events\DTOs\ClassEventDTO;
use WeCoza\Events\Enums\EventType;
use WeCoza\Events\Repositories\ClassEventRepository;
```

Class structure:
- Constructor: `__construct(ClassEventRepository $repository)` with DI
- Static factory: `boot(): self` for quick instantiation

Core dispatch methods:

1. `dispatchClassEvent(EventType $type, int $classId, array $newRow, ?array $oldRow = null): int`
   - Computes diff if oldRow provided
   - Gets current user ID via get_current_user_id()
   - Creates event_data JSONB: {new_row, old_row, diff, metadata: {changed_fields, timestamp}}
   - Inserts via repository
   - Schedules 'wecoza_process_event' via as_enqueue_async_action
   - Returns event_id

2. `dispatchLearnerEvent(EventType $type, int $learnerId, int $classId, array $eventData): int`
   - For learner add/remove/update on a class
   - eventData contains learner details
   - Same flow: insert + schedule async

3. `dispatchStatusChange(int $classId, string $oldStatus, string $newStatus, array $classData): int`
   - Specialized for status changes (significant event)
   - Creates focused diff showing just status change

Helper methods:

4. `private computeDiff(array $old, array $new): array`
   - Returns array of changed fields: {field: {old: x, new: y}}
   - Skips unchanged fields
   - Handles null comparisons

5. `private buildEventData(array $newRow, ?array $oldRow, array $diff, array $metadata = []): array`
   - Standardized event_data structure

6. `private scheduleProcessing(int $eventId): void`
   - Calls as_enqueue_async_action('wecoza_process_event', ['event_id' => $eventId], 'wecoza-notifications')

Add static convenience methods for common cases:
- `static classCreated(int $classId, array $classData): int`
- `static classUpdated(int $classId, array $newData, array $oldData): int`
- `static learnerAdded(int $classId, int $learnerId, array $learnerData): int`
- `static learnerRemoved(int $classId, int $learnerId, array $learnerData): int`

These static methods call boot() internally for simplicity.
  </action>
  <verify>
```bash
php -l src/Events/Services/EventDispatcher.php
```
  </verify>
  <done>EventDispatcher service exists with all dispatch methods and Action Scheduler integration.</done>
</task>

<task type="auto">
  <name>Task 2: Add event filtering configuration</name>
  <files>src/Events/Services/EventDispatcher.php</files>
  <action>
Enhance EventDispatcher with configurable filtering:

Add constants for event significance thresholds:
```php
private const SIGNIFICANT_CLASS_FIELDS = [
    'class_status',
    'start_date',
    'end_date',
    'learner_ids',
    'event_dates',
    'class_facilitator',
    'class_coach',
    'class_assessor',
];
```

Add method:
`isSignificantChange(array $diff): bool`
- Returns true if any SIGNIFICANT_CLASS_FIELDS are in the diff
- Used to filter out minor changes (e.g., notes-only updates)

Add configuration check:
`private shouldDispatch(EventType $type): bool`
- Checks NotificationSettings for enabled event types
- Returns false if notifications disabled for this type

Modify dispatchClassEvent to:
- Check shouldDispatch() first
- For UPDATE events, check isSignificantChange()
- Return 0 if event should not be dispatched (no insert)

This prevents notification spam from minor edits while ensuring important changes are captured.
  </action>
  <verify>
```bash
php -l src/Events/Services/EventDispatcher.php
```
  </verify>
  <done>EventDispatcher has configurable filtering for significant changes.</done>
</task>

</tasks>

<verification>
1. EventDispatcher.php passes PHP lint
2. Class has all required methods: dispatchClassEvent, dispatchLearnerEvent, dispatchStatusChange
3. Static convenience methods exist
4. computeDiff correctly identifies changed fields
5. as_enqueue_async_action is called with correct parameters
</verification>

<success_criteria>
- EventDispatcher can be instantiated via boot()
- Dispatch methods return event_id on success, 0 on skip
- Diff computation works for class data structures
- Action Scheduler integration is correct
</success_criteria>

<output>
After completion, create `.planning/phases/18-notification-system/18-02-SUMMARY.md`
</output>
