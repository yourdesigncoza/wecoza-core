---
phase: 12-performance-async-processing
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/Events/Services/NotificationEnricher.php
  - src/Events/Services/NotificationEmailer.php
  - src/Events/Services/NotificationProcessor.php
  - wecoza-core.php
autonomous: true

must_haves:
  truths:
    - "AI enrichment runs as a separate async job from email sending"
    - "Email sending runs asynchronously via Action Scheduler"
    - "AI enrichment failure does not block email sending for other notifications"
    - "Email sending job is scheduled only after successful AI enrichment"
  artifacts:
    - path: "src/Events/Services/NotificationEnricher.php"
      provides: "AI summary generation as standalone service"
      exports: ["NotificationEnricher"]
      min_lines: 80
    - path: "src/Events/Services/NotificationEmailer.php"
      provides: "Email sending as standalone service"
      exports: ["NotificationEmailer"]
      min_lines: 60
    - path: "src/Events/Services/NotificationProcessor.php"
      provides: "Orchestrator that schedules async jobs"
      contains: "as_enqueue_async_action"
    - path: "wecoza-core.php"
      provides: "Action hooks for async job handlers"
      contains: "wecoza_enrich_notification"
  key_links:
    - from: "src/Events/Services/NotificationProcessor.php"
      to: "Action Scheduler"
      via: "as_enqueue_async_action"
      pattern: "as_enqueue_async_action.*wecoza_enrich"
    - from: "src/Events/Services/NotificationEnricher.php"
      to: "Action Scheduler"
      via: "as_enqueue_async_action for email"
      pattern: "as_enqueue_async_action.*wecoza_send"
    - from: "wecoza-core.php"
      to: "src/Events/Services/NotificationEnricher.php"
      via: "add_action hook handler"
      pattern: "add_action.*wecoza_enrich_notification"
    - from: "wecoza-core.php"
      to: "src/Events/Services/NotificationEmailer.php"
      via: "add_action hook handler"
      pattern: "add_action.*wecoza_send_notification_email"
---

<objective>
Implement async processing by separating AI enrichment from email sending into independent Action Scheduler jobs.

Purpose: Achieve true async notification processing where AI failures don't block emails, and email sending doesn't block web requests. This completes PERF-02 (async email) and PERF-03 (separate AI/email jobs).

Output: NotificationEnricher service, NotificationEmailer service, refactored NotificationProcessor that schedules async jobs.
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-performance-async-processing/12-RESEARCH.md
@.planning/phases/12-performance-async-processing/12-01-SUMMARY.md
@src/Events/Services/NotificationProcessor.php
@src/Events/Services/AISummaryService.php
@src/Events/Services/NotificationSettings.php
@src/Events/Views/Presenters/NotificationEmailPresenter.php
@wecoza-core.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NotificationEnricher service</name>
  <files>src/Events/Services/NotificationEnricher.php</files>
  <action>
Create a new service class that handles AI enrichment for a single notification:

```php
<?php
declare(strict_types=1);

namespace WeCoza\Events\Services;

if (!defined('ABSPATH')) {
    exit;
}

use PDO;
use RuntimeException;
use WeCoza\Core\Database\PostgresConnection;
use WeCoza\Events\Support\OpenAIConfig;

use function error_log;
use function is_array;
use function is_string;
use function json_decode;
use function json_encode;
use function strtolower;
use function strtoupper;
use function absint;
use function do_action;
use function gmdate;
use function wecoza_log;
use const JSON_UNESCAPED_SLASHES;
use const JSON_UNESCAPED_UNICODE;

/**
 * Handles AI enrichment for individual notifications.
 *
 * Designed to run as an Action Scheduler job. On success, schedules
 * the email sending job. On failure, logs error and leaves notification
 * for manual review or retry.
 */
final class NotificationEnricher
{
    private PostgresConnection $db;

    public function __construct(
        private readonly AISummaryService $aiSummaryService,
        private readonly OpenAIConfig $openAIConfig,
        private readonly NotificationSettings $settings
    ) {
        $this->db = PostgresConnection::getInstance();
    }

    public static function boot(): self
    {
        $openAIConfig = new OpenAIConfig();
        $aiSummaryService = new AISummaryService($openAIConfig);
        $settings = new NotificationSettings();

        return new self($aiSummaryService, $openAIConfig, $settings);
    }

    /**
     * Enrich a single notification with AI summary.
     *
     * @param int $logId The log_id to enrich
     * @return array{success: bool, should_email: bool, recipient: ?string, email_context: array}
     */
    public function enrich(int $logId): array
    {
        $row = $this->fetchRow($logId);
        if ($row === null) {
            wecoza_log("NotificationEnricher: Row not found for log_id {$logId}", 'warning');
            return ['success' => false, 'should_email' => false, 'recipient' => null, 'email_context' => []];
        }

        $operation = strtoupper((string) ($row['operation'] ?? ''));
        $recipient = $this->settings->getRecipientForOperation($operation);

        if ($recipient === null) {
            wecoza_log("NotificationEnricher: No recipient for operation {$operation} on log_id {$logId}", 'debug');
            return ['success' => true, 'should_email' => false, 'recipient' => null, 'email_context' => []];
        }

        $newRow = $this->decodeJson($row['new_row'] ?? null);
        $oldRow = $this->decodeJson($row['old_row'] ?? null);
        $diff = $this->decodeJson($row['diff'] ?? null);
        $summaryRecord = $this->decodeJson($row['ai_summary'] ?? null);

        $emailContext = ['alias_map' => [], 'obfuscated' => []];
        $eligibility = $this->openAIConfig->assessEligibility($logId);

        if ($eligibility['eligible'] === false) {
            if ($this->shouldMarkFailure($summaryRecord)) {
                $reason = is_string($eligibility['reason']) ? $eligibility['reason'] : 'feature_disabled';
                $summaryRecord = $this->finalizeSkippedSummary($summaryRecord, $reason);
                $this->persistSummary($logId, $summaryRecord);
                $this->emitSummaryMetrics($logId, $summaryRecord);
            }
        } elseif ($this->shouldGenerateSummary($summaryRecord)) {
            $result = $this->aiSummaryService->generateSummary([
                'log_id' => $logId,
                'operation' => $operation,
                'changed_at' => $row['changed_at'] ?? null,
                'class_id' => $row['class_id'] ?? null,
                'new_row' => $newRow,
                'old_row' => $oldRow,
                'diff' => $diff,
            ], $summaryRecord);

            $summaryRecord = $result->record->toArray();
            $emailContext = $result->emailContext->toArray();
            $this->persistSummary($logId, $summaryRecord);
            $this->emitSummaryMetrics($logId, $summaryRecord);
        }

        return [
            'success' => true,
            'should_email' => true,
            'recipient' => $recipient,
            'email_context' => $emailContext,
        ];
    }

    private function fetchRow(int $logId): ?array
    {
        $sql = <<<SQL
SELECT
    log_id,
    operation,
    changed_at,
    class_id,
    new_row,
    old_row,
    diff,
    ai_summary
FROM class_change_logs
WHERE log_id = :log_id
SQL;

        $stmt = $this->db->getPdo()->prepare($sql);
        if (!$stmt) {
            throw new RuntimeException('Failed to prepare notification query.');
        }

        $stmt->bindValue(':log_id', $logId, PDO::PARAM_INT);

        if (!$stmt->execute()) {
            throw new RuntimeException('Failed to execute notification query.');
        }

        $row = $stmt->fetch(PDO::FETCH_ASSOC);
        return $row !== false ? $row : null;
    }

    private function decodeJson(mixed $value): array
    {
        if ($value === null) {
            return [];
        }

        if (is_array($value)) {
            return $value;
        }

        if (!is_string($value) || $value === '') {
            return [];
        }

        $decoded = json_decode($value, true);
        return is_array($decoded) ? $decoded : [];
    }

    private function shouldGenerateSummary(array $summary): bool
    {
        $status = is_string($summary['status'] ?? null) ? strtolower((string) $summary['status']) : 'pending';
        if ($status === 'success' || $status === 'failed') {
            return false;
        }

        $attempts = absint($summary['attempts'] ?? 0);
        return $attempts < $this->aiSummaryService->getMaxAttempts();
    }

    private function shouldMarkFailure(array $summary): bool
    {
        $status = is_string($summary['status'] ?? null) ? strtolower((string) $summary['status']) : 'pending';
        return $status !== 'failed' && $status !== 'success';
    }

    private function finalizeSkippedSummary(array $summary, string $reason): array
    {
        $normalised = $this->normaliseSummaryPayload($summary);
        $normalised['status'] = 'failed';
        $normalised['error_code'] = $reason;
        $normalised['error_message'] = $this->getSkipMessage($reason);
        if (!is_string($normalised['generated_at']) || $normalised['generated_at'] === '') {
            $normalised['generated_at'] = gmdate('c');
        }

        return $normalised;
    }

    private function getSkipMessage(string $reason): string
    {
        $messages = [
            'config_missing' => 'OpenAI configuration missing or invalid.',
            'feature_disabled' => 'AI summaries disabled via admin settings.',
        ];
        return $messages[$reason] ?? 'AI summary skipped.';
    }

    private function normaliseSummaryPayload(array $summary): array
    {
        return [
            'summary' => $summary['summary'] ?? null,
            'status' => (string) ($summary['status'] ?? 'pending'),
            'error_code' => $summary['error_code'] ?? null,
            'error_message' => $summary['error_message'] ?? null,
            'attempts' => absint($summary['attempts'] ?? 0),
            'viewed' => (bool) ($summary['viewed'] ?? false),
            'viewed_at' => $summary['viewed_at'] ?? null,
            'generated_at' => $summary['generated_at'] ?? null,
            'model' => $summary['model'] ?? null,
            'tokens_used' => isset($summary['tokens_used']) ? (int) $summary['tokens_used'] : 0,
            'processing_time_ms' => isset($summary['processing_time_ms']) ? (int) $summary['processing_time_ms'] : 0,
        ];
    }

    private function persistSummary(int $logId, array $summary): void
    {
        $stmt = $this->db->getPdo()->prepare('UPDATE class_change_logs SET ai_summary = :summary WHERE log_id = :log_id');
        if (!$stmt) {
            throw new RuntimeException('Failed to prepare AI summary update.');
        }

        $payload = json_encode($summary, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);
        if ($payload === false) {
            $payload = '{}';
        }
        $stmt->bindValue(':summary', $payload, PDO::PARAM_STR);
        $stmt->bindValue(':log_id', $logId, PDO::PARAM_INT);

        $stmt->execute();
    }

    private function emitSummaryMetrics(int $logId, array $summary): void
    {
        do_action('wecoza_ai_summary_generated', [
            'log_id' => $logId,
            'status' => $summary['status'] ?? 'pending',
            'model' => $summary['model'] ?? null,
            'tokens_used' => $summary['tokens_used'] ?? 0,
            'processing_time_ms' => $summary['processing_time_ms'] ?? 0,
            'attempts' => $summary['attempts'] ?? 0,
        ]);
    }
}
```

This extracts the AI enrichment logic from NotificationProcessor into a focused service that:
- Fetches a single row by log_id
- Performs AI enrichment (or marks as skipped)
- Returns result indicating whether email should be sent
  </action>
  <verify>
1. `php -l src/Events/Services/NotificationEnricher.php` returns no errors
2. `grep "class NotificationEnricher" src/Events/Services/NotificationEnricher.php` confirms class exists
3. `grep "public function enrich" src/Events/Services/NotificationEnricher.php` confirms main method
  </verify>
  <done>NotificationEnricher service handles AI enrichment for single notifications</done>
</task>

<task type="auto">
  <name>Task 2: Create NotificationEmailer service</name>
  <files>src/Events/Services/NotificationEmailer.php</files>
  <action>
Create a new service class that handles email sending for a single notification:

```php
<?php
declare(strict_types=1);

namespace WeCoza\Events\Services;

if (!defined('ABSPATH')) {
    exit;
}

use PDO;
use RuntimeException;
use WeCoza\Core\Database\PostgresConnection;
use WeCoza\Events\Views\Presenters\NotificationEmailPresenter;

use function error_log;
use function is_array;
use function is_string;
use function json_decode;
use function strtoupper;
use function sprintf;
use function wp_mail;
use function wecoza_log;

/**
 * Handles email sending for individual notifications.
 *
 * Designed to run as an Action Scheduler job. Fetches notification data,
 * formats email via presenter, and sends via wp_mail.
 */
final class NotificationEmailer
{
    private PostgresConnection $db;

    public function __construct(
        private readonly NotificationEmailPresenter $presenter
    ) {
        $this->db = PostgresConnection::getInstance();
    }

    public static function boot(): self
    {
        $presenter = new NotificationEmailPresenter();
        return new self($presenter);
    }

    /**
     * Send email for a single notification.
     *
     * @param int $logId The log_id to send email for
     * @param string $recipient Email recipient
     * @param array $emailContext Context from AI enrichment (alias_map, obfuscated)
     * @return bool True if email sent successfully
     */
    public function send(int $logId, string $recipient, array $emailContext = []): bool
    {
        $row = $this->fetchRow($logId);
        if ($row === null) {
            wecoza_log("NotificationEmailer: Row not found for log_id {$logId}", 'warning');
            return false;
        }

        $operation = strtoupper((string) ($row['operation'] ?? ''));
        $newRow = $this->decodeJson($row['new_row'] ?? null);
        $oldRow = $this->decodeJson($row['old_row'] ?? null);
        $diff = $this->decodeJson($row['diff'] ?? null);
        $summaryRecord = $this->decodeJson($row['ai_summary'] ?? null);

        $mailData = $this->presenter->present([
            'operation' => $operation,
            'row' => $row,
            'recipient' => $recipient,
            'new_row' => $newRow,
            'old_row' => $oldRow,
            'diff' => $diff,
            'summary' => $summaryRecord,
            'email_context' => $emailContext,
        ]);

        $subject = $mailData['subject'];
        $body = $mailData['body'];
        $headers = $mailData['headers'];

        $sent = wp_mail($recipient, $subject, $body, $headers);

        if (!$sent) {
            error_log(sprintf('WeCoza notification failed for row %d to %s', $logId, $recipient));
        } else {
            wecoza_log(sprintf('WeCoza notification sent for row %d to %s', $logId, $recipient), 'debug');
        }

        return $sent;
    }

    private function fetchRow(int $logId): ?array
    {
        $sql = <<<SQL
SELECT
    log_id,
    operation,
    changed_at,
    class_id,
    new_row,
    old_row,
    diff,
    ai_summary
FROM class_change_logs
WHERE log_id = :log_id
SQL;

        $stmt = $this->db->getPdo()->prepare($sql);
        if (!$stmt) {
            throw new RuntimeException('Failed to prepare notification query.');
        }

        $stmt->bindValue(':log_id', $logId, PDO::PARAM_INT);

        if (!$stmt->execute()) {
            throw new RuntimeException('Failed to execute notification query.');
        }

        $row = $stmt->fetch(PDO::FETCH_ASSOC);
        return $row !== false ? $row : null;
    }

    private function decodeJson(mixed $value): array
    {
        if ($value === null) {
            return [];
        }

        if (is_array($value)) {
            return $value;
        }

        if (!is_string($value) || $value === '') {
            return [];
        }

        $decoded = json_decode($value, true);
        return is_array($decoded) ? $decoded : [];
    }
}
```

This extracts the email sending logic from NotificationProcessor into a focused service that:
- Fetches notification data by log_id
- Formats email using the existing presenter
- Sends via wp_mail
  </action>
  <verify>
1. `php -l src/Events/Services/NotificationEmailer.php` returns no errors
2. `grep "class NotificationEmailer" src/Events/Services/NotificationEmailer.php` confirms class exists
3. `grep "public function send" src/Events/Services/NotificationEmailer.php` confirms main method
  </verify>
  <done>NotificationEmailer service handles email sending for single notifications</done>
</task>

<task type="auto">
  <name>Task 3: Refactor NotificationProcessor to schedule async jobs and register hooks</name>
  <files>src/Events/Services/NotificationProcessor.php, wecoza-core.php</files>
  <action>
**Part A: Refactor NotificationProcessor to schedule jobs instead of inline processing**

Replace the current inline processing in `process()` with Action Scheduler job scheduling:

1. Remove unused imports that are now in NotificationEnricher/NotificationEmailer:
   - Keep: PDO, RuntimeException, PostgresConnection, NotificationSettings, OpenAIConfig
   - Remove: NotificationEmailPresenter (moved to NotificationEmailer)
   - Remove: AISummaryService (moved to NotificationEnricher)

2. Update constructor to only keep what's needed for orchestration:
   ```php
   public function __construct(
       private readonly NotificationSettings $settings,
       private readonly OpenAIConfig $openAIConfig
   ) {
       $this->db = PostgresConnection::getInstance();
   }

   public static function boot(): self
   {
       $openAIConfig = new OpenAIConfig();
       return new self(new NotificationSettings(), $openAIConfig);
   }
   ```

3. Replace the inline processing in the foreach loop with job scheduling:
   ```php
   foreach ($rows as $row) {
       $iteration++;
       if ($this->shouldStop($start)) {
           break;
       }

       $latestId = max($latestId, (int) $row['log_id']);
       $logId = (int) $row['log_id'];
       $operation = strtoupper((string) ($row['operation'] ?? ''));

       // Check if this operation has a recipient configured
       $recipient = $this->settings->getRecipientForOperation($operation);
       if ($recipient === null) {
           continue;
       }

       // Check AI eligibility to decide which job to schedule
       $eligibility = $this->openAIConfig->assessEligibility($logId);
       $needsAI = $eligibility['eligible'] !== false;

       if ($needsAI) {
           // Schedule AI enrichment first (will chain to email on success)
           as_enqueue_async_action(
               'wecoza_enrich_notification',
               ['log_id' => $logId],
               'wecoza-notifications'
           );
       } else {
           // Skip AI, schedule email directly
           as_enqueue_async_action(
               'wecoza_send_notification_email',
               ['log_id' => $logId, 'recipient' => $recipient, 'email_context' => []],
               'wecoza-notifications'
           );
       }

       // Periodic memory cleanup
       if ($this->shouldCleanupMemory($iteration)) {
           gc_collect_cycles();

           if (defined('WP_DEBUG') && WP_DEBUG) {
               wecoza_log(sprintf(
                   'NotificationProcessor: Memory cleanup at iteration %d, usage: %s MB',
                   $iteration,
                   round(memory_get_usage(true) / 1048576, 2)
               ), 'debug');
           }
       }
   }
   ```

4. Remove methods that are now in NotificationEnricher (keep just orchestration methods):
   - REMOVE: decodeJson, shouldGenerateSummary, shouldMarkFailure, finalizeSkippedSummary, normaliseSummaryPayload, persistSummary, emitSummaryMetrics, SKIP_MESSAGES constant
   - KEEP: fetchRows, shouldStop, acquireLock, releaseLock, refreshLock, shouldCleanupMemory, performMemoryCleanup

5. Update the imports at the top:
   ```php
   use function as_enqueue_async_action;
   ```

**Part B: Register Action Scheduler hooks in wecoza-core.php**

After the "Email Notification Cron Handler" section (around line 244), add the Action Scheduler job handlers:

```php
// Action Scheduler Job Handlers for Async Notifications
add_action('wecoza_enrich_notification', function (int $logId) {
    if (!class_exists(\WeCoza\Events\Services\NotificationEnricher::class)) {
        return;
    }

    $enricher = \WeCoza\Events\Services\NotificationEnricher::boot();
    $result = $enricher->enrich($logId);

    if ($result['success'] && $result['should_email'] && $result['recipient'] !== null) {
        // Chain to email job
        as_enqueue_async_action(
            'wecoza_send_notification_email',
            [
                'log_id' => $logId,
                'recipient' => $result['recipient'],
                'email_context' => $result['email_context'],
            ],
            'wecoza-notifications'
        );
    }
}, 10, 1);

add_action('wecoza_send_notification_email', function (int $logId, string $recipient, array $emailContext = []) {
    if (!class_exists(\WeCoza\Events\Services\NotificationEmailer::class)) {
        return;
    }

    $emailer = \WeCoza\Events\Services\NotificationEmailer::boot();
    $emailer->send($logId, $recipient, $emailContext);
}, 10, 3);
```

Why this design:
- NotificationProcessor (WP-Cron triggered) fetches batch and schedules jobs
- NotificationEnricher (AS job) handles AI and chains to email
- NotificationEmailer (AS job) handles email sending
- Each can fail independently without blocking others
  </action>
  <verify>
1. `php -l src/Events/Services/NotificationProcessor.php` returns no errors
2. `grep "as_enqueue_async_action" src/Events/Services/NotificationProcessor.php` shows job scheduling
3. `grep "wecoza_enrich_notification" wecoza-core.php` shows hook registration
4. `grep "wecoza_send_notification_email" wecoza-core.php` shows hook registration
5. `php -l wecoza-core.php` returns no errors
  </verify>
  <done>NotificationProcessor schedules async jobs, handlers registered in wecoza-core.php</done>
</task>

</tasks>

<verification>
Phase verification after all tasks complete:

1. **New services exist and are valid PHP:**
   ```bash
   php -l src/Events/Services/NotificationEnricher.php
   php -l src/Events/Services/NotificationEmailer.php
   php -l src/Events/Services/NotificationProcessor.php
   php -l wecoza-core.php
   ```
   Expected: All return "No syntax errors"

2. **NotificationProcessor schedules async jobs:**
   ```bash
   grep "as_enqueue_async_action" src/Events/Services/NotificationProcessor.php
   ```
   Expected: Shows calls for wecoza_enrich_notification and wecoza_send_notification_email

3. **Action handlers registered:**
   ```bash
   grep -A5 "add_action('wecoza_enrich_notification'" wecoza-core.php
   grep -A5 "add_action('wecoza_send_notification_email'" wecoza-core.php
   ```
   Expected: Shows handler registrations

4. **Services loadable:**
   ```bash
   wp eval "echo class_exists('\\WeCoza\\Events\\Services\\NotificationEnricher') ? 'Enricher OK' : 'Enricher missing';"
   wp eval "echo class_exists('\\WeCoza\\Events\\Services\\NotificationEmailer') ? 'Emailer OK' : 'Emailer missing';"
   ```
   Expected: Both return "OK"

5. **Hook handlers registered:**
   ```bash
   wp eval "echo has_action('wecoza_enrich_notification') ? 'enrich hook OK' : 'enrich hook missing';"
   wp eval "echo has_action('wecoza_send_notification_email') ? 'email hook OK' : 'email hook missing';"
   ```
   Expected: Both return "OK"
</verification>

<success_criteria>
- PERF-02 satisfied: Email sending runs via Action Scheduler (async)
- PERF-03 satisfied: AI enrichment and email sending are separate jobs
- Job chaining works (AI success schedules email)
- Independent failure (AI failure doesn't block other emails)
- No PHP syntax errors
- All hooks registered and handlers loadable
</success_criteria>

<output>
After completion, create `.planning/phases/12-performance-async-processing/12-02-SUMMARY.md`
</output>
