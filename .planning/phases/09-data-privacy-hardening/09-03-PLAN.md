---
phase: 09-data-privacy-hardening
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/Events/Services/NotificationProcessor.php
autonomous: true

must_haves:
  truths:
    - "NotificationProcessor releases memory periodically during batch processing"
    - "Garbage collection triggered at defined intervals (not every iteration)"
    - "Large datasets don't cause monotonic memory growth"
  artifacts:
    - path: "src/Events/Services/NotificationProcessor.php"
      provides: "Memory-optimized batch processing"
      contains: "gc_collect_cycles"
  key_links:
    - from: "NotificationProcessor::process"
      to: "gc_collect_cycles()"
      via: "periodic cleanup in loop"
      pattern: "gc_collect_cycles"
---

<objective>
Add periodic memory cleanup to NotificationProcessor for long-running obfuscation operations (PERF-05).

Purpose: When processing large batches of notifications, obfuscation state accumulates (aliases array grows). Without periodic cleanup, memory grows monotonically. Adding unset() + gc_collect_cycles() at intervals prevents memory bloat.

Output: NotificationProcessor with periodic memory cleanup during batch processing.
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-data-privacy-hardening/09-RESEARCH.md
@src/Events/Services/NotificationProcessor.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add memory cleanup constants and helper method</name>
  <files>src/Events/Services/NotificationProcessor.php</files>
  <action>
Add memory cleanup infrastructure to NotificationProcessor:

1. **Add cleanup interval constant** (after line 46, with other constants):
   ```php
   private const MEMORY_CLEANUP_INTERVAL = 50;  // Every 50 records
   ```

2. **Add gc_collect_cycles to use statements** (around line 27, add if not present):
   ```php
   use function gc_collect_cycles;
   ```

3. **Add memory cleanup helper method** (after releaseLock method, around line 323):
   ```php
   /**
    * Perform periodic memory cleanup during batch processing.
    *
    * Uses unset() for immediate release and gc_collect_cycles() for
    * cyclic references in obfuscation state.
    *
    * @param mixed $data Data to release (passed by reference)
    */
   private function performMemoryCleanup(mixed &$data): void
   {
       unset($data);
       gc_collect_cycles();
   }

   /**
    * Check if memory cleanup should run based on iteration count.
    */
   private function shouldCleanupMemory(int $iteration): bool
   {
       return $iteration > 0 && ($iteration % self::MEMORY_CLEANUP_INTERVAL === 0);
   }
   ```

This establishes the foundation for memory management without changing the main processing logic yet.
  </action>
  <verify>
```bash
# Verify constant added
grep -n "MEMORY_CLEANUP_INTERVAL" src/Events/Services/NotificationProcessor.php

# Verify gc_collect_cycles import
grep -n "gc_collect_cycles" src/Events/Services/NotificationProcessor.php

# Verify helper methods added
grep -n "performMemoryCleanup" src/Events/Services/NotificationProcessor.php
grep -n "shouldCleanupMemory" src/Events/Services/NotificationProcessor.php
```
  </verify>
  <done>
- MEMORY_CLEANUP_INTERVAL constant defined (50 records)
- gc_collect_cycles function imported
- performMemoryCleanup() helper method added
- shouldCleanupMemory() helper method added
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate memory cleanup into process() loop</name>
  <files>src/Events/Services/NotificationProcessor.php</files>
  <action>
Modify the process() method to include periodic memory cleanup:

1. **Add iteration counter** (inside process() method, before foreach loop, around line 84):
   ```php
   $rows = $this->fetchRows($lastProcessed, self::BATCH_LIMIT);
   $iteration = 0;  // ADD THIS

   foreach ($rows as $row) {
       $iteration++;  // ADD THIS at start of loop
   ```

2. **Add memory cleanup at end of each iteration** (before the closing brace of foreach, around line 151):
   ```php
               // ... existing code for wp_mail ...
               if (!$sent) {
                   error_log(sprintf('WeCoza notification failed for row %d to %s', (int) $row['log_id'], $recipient));
               }

               // Periodic memory cleanup for large batches
               if ($this->shouldCleanupMemory($iteration)) {
                   // Release email-related data
                   unset($mailData, $body, $subject, $headers);
                   unset($newRow, $oldRow, $diff, $summaryRecord, $emailContext);

                   // Trigger garbage collection
                   gc_collect_cycles();

                   // Optional: Log memory usage for monitoring
                   if (defined('WP_DEBUG') && WP_DEBUG) {
                       wecoza_log(sprintf(
                           'NotificationProcessor: Memory cleanup at iteration %d, usage: %s MB',
                           $iteration,
                           round(memory_get_usage(true) / 1048576, 2)
                       ), 'debug');
                   }
               }
           }  // end foreach
   ```

3. **Add final cleanup after loop** (after the foreach loop ends, before the if statement that updates option):
   ```php
           }  // end foreach

           // Final memory cleanup after batch
           gc_collect_cycles();

           if ($latestId !== $lastProcessed) {
   ```

Note: Current BATCH_LIMIT is 1, so cleanup won't trigger often. This prepares for when BATCH_LIMIT increases (see PERF-01 in Phase 12).
  </action>
  <verify>
```bash
# Verify iteration counter added
grep -n "\$iteration" src/Events/Services/NotificationProcessor.php

# Verify shouldCleanupMemory called
grep -n "shouldCleanupMemory" src/Events/Services/NotificationProcessor.php

# Verify gc_collect_cycles called in loop
grep -c "gc_collect_cycles" src/Events/Services/NotificationProcessor.php
# Expected: at least 2 (in helper + final cleanup)
```
  </verify>
  <done>
- Iteration counter tracks processed rows
- shouldCleanupMemory() called every MEMORY_CLEANUP_INTERVAL iterations
- Variables unset before garbage collection
- Final gc_collect_cycles() after batch completes
- Debug logging available when WP_DEBUG enabled
  </done>
</task>

<task type="auto">
  <name>Task 3: Add wecoza_log import if missing</name>
  <files>src/Events/Services/NotificationProcessor.php</files>
  <action>
Ensure wecoza_log function is available for debug logging:

1. **Check if wecoza_log is imported** (in use function statements):
   Look for `use function wecoza_log;` in the file header.

2. **If missing, add it** (after other use function statements, around line 37):
   ```php
   use function wecoza_log;
   ```

If wecoza_log is already imported via another mechanism (global function), skip this step.

The wecoza_log function is defined in core/Helpers/functions.php and is auto-loaded, so it should be available. Adding the explicit use statement improves code clarity.
  </action>
  <verify>
```bash
# Check if wecoza_log is used
grep -n "wecoza_log" src/Events/Services/NotificationProcessor.php

# Verify PHP syntax is valid
php -l src/Events/Services/NotificationProcessor.php
```
  </verify>
  <done>
- wecoza_log function available for debug logging
- PHP syntax remains valid
- Memory cleanup logs visible in debug.log when WP_DEBUG enabled
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **PERF-05 Verification - Memory cleanup exists:**
   ```bash
   grep -c "gc_collect_cycles" src/Events/Services/NotificationProcessor.php
   # Expected: 2 or more

   grep -c "MEMORY_CLEANUP_INTERVAL" src/Events/Services/NotificationProcessor.php
   # Expected: 1
   ```

2. **Code quality verification:**
   ```bash
   php -l src/Events/Services/NotificationProcessor.php
   # Expected: No syntax errors
   ```

3. **Pattern verification:**
   ```bash
   grep -A3 "shouldCleanupMemory" src/Events/Services/NotificationProcessor.php | head -10
   # Should show cleanup logic
   ```
</verification>

<success_criteria>
- [ ] MEMORY_CLEANUP_INTERVAL constant defined (50)
- [ ] gc_collect_cycles imported and used
- [ ] performMemoryCleanup() helper method exists
- [ ] shouldCleanupMemory() helper method exists
- [ ] process() loop includes periodic cleanup
- [ ] Final gc_collect_cycles() after batch
- [ ] PHP syntax valid
</success_criteria>

<output>
After completion, create `.planning/phases/09-data-privacy-hardening/09-03-SUMMARY.md`
</output>
