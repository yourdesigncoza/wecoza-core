---
phase: 09-data-privacy-hardening
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/Events/Services/Traits/PIIDetector.php
  - src/Events/Services/Traits/DataObfuscator.php
autonomous: true

must_haves:
  truths:
    - "Values matching SA ID pattern (13 digits) are auto-detected and masked"
    - "Values matching phone pattern (7+ digits) are auto-detected and masked"
    - "Values matching passport pattern (6-12 alphanumeric) are auto-detected in relevant fields"
    - "Detection works on field VALUES, not just field names"
  artifacts:
    - path: "src/Events/Services/Traits/PIIDetector.php"
      provides: "Heuristic PII pattern detection methods"
      exports: ["looksLikeSouthAfricanID", "looksLikePassport", "detectPIIPattern"]
    - path: "src/Events/Services/Traits/DataObfuscator.php"
      provides: "Obfuscation using PIIDetector for value-based detection"
      contains: "use PIIDetector"
  key_links:
    - from: "src/Events/Services/Traits/DataObfuscator.php"
      to: "PIIDetector trait"
      via: "trait use statement"
      pattern: "use PIIDetector"
    - from: "DataObfuscator::obfuscateString"
      to: "PIIDetector::detectPIIPattern"
      via: "method call"
      pattern: "detectPIIPattern"
---

<objective>
Add heuristic PII detection for custom fields by inspecting VALUES for patterns like South African ID numbers, passport numbers, and phone numbers (SEC-06).

Purpose: Current obfuscation only checks field names. PII can appear in unexpected fields (notes, custom attributes, reference_number). Heuristic detection inspects the actual VALUE to catch PII patterns regardless of field name.

Output: PIIDetector trait with pattern-matching methods, integrated into DataObfuscator for value-based PII detection.
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-data-privacy-hardening/09-RESEARCH.md
@.planning/phases/09-data-privacy-hardening/09-01-SUMMARY.md
@src/Events/Services/Traits/DataObfuscator.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PIIDetector trait with pattern detection methods</name>
  <files>src/Events/Services/Traits/PIIDetector.php</files>
  <action>
Create a new PIIDetector trait in `src/Events/Services/Traits/PIIDetector.php`:

```php
<?php
declare(strict_types=1);

namespace WeCoza\Events\Services\Traits;

if (!defined('ABSPATH')) {
    exit;
}

use function preg_match;
use function preg_replace;
use function strlen;
use function str_repeat;
use function substr;

/**
 * Heuristic PII pattern detection for field values.
 *
 * Detects PII patterns in values regardless of field name:
 * - South African ID numbers (13 digits)
 * - Passport numbers (6-12 alphanumeric)
 * - Phone numbers (7-15 digits)
 */
trait PIIDetector
{
    /**
     * Detect if a value looks like a South African ID number.
     * SA ID format: 13 digits (YYMMDD + 4 digits + citizenship + gender digit + checksum)
     */
    private function looksLikeSouthAfricanID(string $value): bool
    {
        $cleaned = preg_replace('/[^0-9]/', '', $value);
        return $cleaned !== null && strlen($cleaned) === 13;
    }

    /**
     * Detect if a value looks like a passport number.
     * International passports: 6-12 alphanumeric characters.
     */
    private function looksLikePassport(string $value): bool
    {
        // Only match if primarily alphanumeric and right length
        // Avoid matching common IDs, codes, etc.
        $value = trim($value);
        if (strlen($value) < 6 || strlen($value) > 12) {
            return false;
        }

        // Must be alphanumeric only
        return preg_match('/^[A-Z0-9]{6,12}$/i', $value) === 1;
    }

    /**
     * Detect if a value looks like a phone number.
     * Phone numbers: 7-15 digits (handles various formats with dashes, spaces, etc.)
     */
    private function looksLikePhoneNumber(string $value): bool
    {
        $digits = preg_replace('/[^0-9]/', '', $value);
        if ($digits === null) {
            return false;
        }

        $length = strlen($digits);
        return $length >= 7 && $length <= 15;
    }

    /**
     * Detect PII pattern in a value, returning the pattern type or null.
     *
     * Order matters: more specific patterns first (SA ID before phone).
     *
     * @return string|null Pattern type: 'sa_id', 'passport', 'phone', or null
     */
    private function detectPIIPattern(string $value): ?string
    {
        // Skip very short values (likely codes, not PII)
        if (strlen(trim($value)) < 6) {
            return null;
        }

        // SA ID is most specific (exactly 13 digits)
        if ($this->looksLikeSouthAfricanID($value)) {
            return 'sa_id';
        }

        // Passport: alphanumeric 6-12 chars (check before phone to avoid overlap)
        // Only flag as passport if field context suggests it
        // (handled by caller with field name hints)

        // Phone: 7-15 digits (most common pattern)
        if ($this->looksLikePhoneNumber($value)) {
            return 'phone';
        }

        return null;
    }

    /**
     * Mask a South African ID number.
     * Shows last 2 digits for partial verification.
     */
    private function maskSouthAfricanID(string $value): string
    {
        $cleaned = preg_replace('/[^0-9]/', '', $value) ?? '';
        if (strlen($cleaned) !== 13) {
            return 'ID-XXXXXXXXXXXXX';
        }

        // Show last 2 digits for verification
        return 'ID-XXXXXXXXXXX' . substr($cleaned, -2);
    }

    /**
     * Mask a passport number.
     */
    private function maskPassport(string $value): string
    {
        $value = trim($value);
        if (strlen($value) < 6) {
            return 'PASSPORT-XXXX';
        }

        // Show last 2 characters for verification
        return 'PASSPORT-' . str_repeat('X', max(strlen($value) - 2, 2)) . substr($value, -2);
    }
}
```

Key design decisions:
- SA ID detection uses 13-digit pattern (South African standard)
- Phone detection uses 7-15 digit range (covers international formats)
- Passport detection is conservative (alphanumeric 6-12, needs field name hint)
- Masking shows last 2 chars for verification without exposing full PII
  </action>
  <verify>
```bash
# Verify file created with expected content
test -f src/Events/Services/Traits/PIIDetector.php && echo "File exists"
grep -c "trait PIIDetector" src/Events/Services/Traits/PIIDetector.php
grep -c "looksLikeSouthAfricanID" src/Events/Services/Traits/PIIDetector.php
grep -c "detectPIIPattern" src/Events/Services/Traits/PIIDetector.php
```
  </verify>
  <done>
- PIIDetector.php created in src/Events/Services/Traits/
- Contains looksLikeSouthAfricanID(), looksLikePassport(), looksLikePhoneNumber()
- Contains detectPIIPattern() for unified detection
- Contains maskSouthAfricanID(), maskPassport() for obfuscation
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate PIIDetector into DataObfuscator for value-based detection</name>
  <files>src/Events/Services/Traits/DataObfuscator.php</files>
  <action>
Modify DataObfuscator to use PIIDetector for heuristic value-based PII detection:

1. **Add use statement for PIIDetector trait** (after line 33):
   ```php
   trait DataObfuscator
   {
       use PIIDetector;
       // ... existing code
   ```

2. **Enhance obfuscateString() to use value-based detection** (around line 167-189):
   Current logic checks field names first, then email/phone patterns.
   Add heuristic detection BEFORE returning the raw value:

   ```php
   private function obfuscateString(string $key, string $value, array &$state, ?string $parentKey): string
   {
       $normalizedKey = strtolower($key);
       $normalizedParent = $parentKey !== null ? strtolower($parentKey) : '';

       if ($this->shouldAliasName($normalizedKey, $normalizedParent, $value)) {
           return $this->aliasName($value, $state);
       }

       if ($this->shouldMaskIdentifier($normalizedKey, $normalizedParent, $value)) {
           return 'ID-XXX';
       }

       if ($this->looksLikeEmail($value)) {
           return $this->maskEmail($value);
       }

       // Phone is already detected in looksLikePhone (existing method)
       if ($this->looksLikePhone($value)) {
           return $this->maskPhone($value);
       }

       // NEW: Heuristic PII detection for values in non-standard fields
       $piiPattern = $this->detectPIIPattern($value);
       if ($piiPattern !== null) {
           return $this->maskDetectedPII($value, $piiPattern, $normalizedKey);
       }

       return $value;
   }
   ```

3. **Add maskDetectedPII() method** (after maskPhone method):
   ```php
   /**
    * Mask a value based on detected PII pattern type.
    * Uses field name hints to refine passport detection.
    */
   private function maskDetectedPII(string $value, string $patternType, string $fieldKey): string
   {
       return match ($patternType) {
           'sa_id' => $this->maskSouthAfricanID($value),
           'passport' => $this->shouldTreatAsPassport($fieldKey) ? $this->maskPassport($value) : $value,
           'phone' => $this->maskPhone($value),
           default => $value,
       };
   }

   /**
    * Check if field name suggests passport content.
    * Reduces false positives for passport detection.
    */
   private function shouldTreatAsPassport(string $fieldKey): bool
   {
       return str_contains($fieldKey, 'passport')
           || str_contains($fieldKey, 'travel')
           || str_contains($fieldKey, 'document');
   }
   ```

Note: The existing looksLikePhone() in DataObfuscator overlaps with PIIDetector. Keep both - the existing one triggers first via explicit check, PIIDetector is fallback for non-standard fields.
  </action>
  <verify>
```bash
# Verify PIIDetector trait is used
grep -n "use PIIDetector" src/Events/Services/Traits/DataObfuscator.php

# Verify detectPIIPattern is called
grep -n "detectPIIPattern" src/Events/Services/Traits/DataObfuscator.php

# Verify maskDetectedPII method exists
grep -n "maskDetectedPII" src/Events/Services/Traits/DataObfuscator.php

# Verify maskSouthAfricanID is available (from trait)
grep -n "maskSouthAfricanID" src/Events/Services/Traits/PIIDetector.php
```
  </verify>
  <done>
- DataObfuscator uses PIIDetector trait
- obfuscateString() calls detectPIIPattern() for value-based detection
- maskDetectedPII() routes to appropriate masking method
- SA ID values (13 digits) are auto-detected and masked
- Field name hints prevent passport false positives
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit test coverage for PIIDetector patterns</name>
  <files>tests/Events/PIIDetectorTest.php</files>
  <action>
Create a focused test file for PIIDetector pattern detection:

```php
<?php
declare(strict_types=1);

namespace WeCoza\Tests\Events;

// Bootstrap WordPress test environment
$bootstrap = dirname(__DIR__, 2) . '/tests/bootstrap.php';
if (file_exists($bootstrap)) {
    require_once $bootstrap;
}

use WeCoza\Tests\TestRunner;

// Include the trait for testing
require_once dirname(__DIR__, 2) . '/src/Events/Services/Traits/PIIDetector.php';

/**
 * Test class that uses PIIDetector trait for testing.
 */
class PIIDetectorTestClass
{
    use \WeCoza\Events\Services\Traits\PIIDetector;

    // Expose private methods for testing
    public function testLooksLikeSouthAfricanID(string $value): bool
    {
        return $this->looksLikeSouthAfricanID($value);
    }

    public function testLooksLikePhoneNumber(string $value): bool
    {
        return $this->looksLikePhoneNumber($value);
    }

    public function testDetectPIIPattern(string $value): ?string
    {
        return $this->detectPIIPattern($value);
    }

    public function testMaskSouthAfricanID(string $value): string
    {
        return $this->maskSouthAfricanID($value);
    }

    public function testMaskPassport(string $value): string
    {
        return $this->maskPassport($value);
    }
}

$runner = new TestRunner('PIIDetector Pattern Detection');

// Section 1: South African ID Detection
$runner->section('South African ID Detection');

$detector = new PIIDetectorTestClass();

// Valid SA IDs (13 digits)
$runner->test('SA ID: 13 digits detected', $detector->testLooksLikeSouthAfricanID('9001015800087'));
$runner->test('SA ID: 13 digits with spaces detected', $detector->testLooksLikeSouthAfricanID('900101 5800 087'));
$runner->test('SA ID: 13 digits with dashes detected', $detector->testLooksLikeSouthAfricanID('900101-5800-087'));

// Invalid SA IDs
$runner->test('SA ID: 12 digits not detected', !$detector->testLooksLikeSouthAfricanID('123456789012'));
$runner->test('SA ID: 14 digits not detected', !$detector->testLooksLikeSouthAfricanID('12345678901234'));
$runner->test('SA ID: letters not detected', !$detector->testLooksLikeSouthAfricanID('900101ABC0087'));

// Section 2: Phone Number Detection
$runner->section('Phone Number Detection');

// Valid phone numbers (7-15 digits)
$runner->test('Phone: 10 digits detected', $detector->testLooksLikePhoneNumber('0821234567'));
$runner->test('Phone: with spaces detected', $detector->testLooksLikePhoneNumber('082 123 4567'));
$runner->test('Phone: international format detected', $detector->testLooksLikePhoneNumber('+27 82 123 4567'));
$runner->test('Phone: 7 digits detected', $detector->testLooksLikePhoneNumber('1234567'));

// Invalid phone numbers
$runner->test('Phone: 6 digits not detected', !$detector->testLooksLikePhoneNumber('123456'));
$runner->test('Phone: 16+ digits not detected', !$detector->testLooksLikePhoneNumber('1234567890123456'));

// Section 3: Pattern Detection Priority
$runner->section('PII Pattern Detection');

// SA ID takes priority over phone (more specific)
$runner->test('Pattern: SA ID detected (not phone)', $detector->testDetectPIIPattern('9001015800087') === 'sa_id');

// Phone detection
$runner->test('Pattern: Phone detected', $detector->testDetectPIIPattern('0821234567') === 'phone');

// Short values ignored
$runner->test('Pattern: Short value returns null', $detector->testDetectPIIPattern('12345') === null);

// Section 4: Masking
$runner->section('PII Masking');

$runner->test('Mask SA ID shows last 2 digits', $detector->testMaskSouthAfricanID('9001015800087') === 'ID-XXXXXXXXXXX87');
$runner->test('Mask passport shows last 2 chars', $detector->testMaskPassport('AB123456') === 'PASSPORT-XXXXXX56');

$runner->summary();
```
  </action>
  <verify>
```bash
# Run the test
php tests/Events/PIIDetectorTest.php 2>&1 | head -50

# Check for any failures
php tests/Events/PIIDetectorTest.php 2>&1 | grep -E "(PASS|FAIL)"
```
  </verify>
  <done>
- PIIDetectorTest.php created with pattern detection tests
- SA ID detection tests pass (13 digits, with formatting)
- Phone detection tests pass (7-15 digits range)
- Masking tests verify last 2 chars visible
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **SEC-06 Verification - Heuristic detection exists:**
   ```bash
   grep -c "detectPIIPattern" src/Events/Services/Traits/DataObfuscator.php
   # Expected: at least 1

   grep -c "looksLikeSouthAfricanID" src/Events/Services/Traits/PIIDetector.php
   # Expected: at least 1
   ```

2. **Integration verification:**
   ```bash
   grep -c "use PIIDetector" src/Events/Services/Traits/DataObfuscator.php
   # Expected: 1
   ```

3. **Test verification:**
   ```bash
   php tests/Events/PIIDetectorTest.php 2>&1 | grep -E "PASS|FAIL"
   ```
</verification>

<success_criteria>
- [ ] PIIDetector.php trait created with detection methods
- [ ] DataObfuscator uses PIIDetector trait
- [ ] obfuscateString() calls detectPIIPattern() for value-based detection
- [ ] SA ID pattern (13 digits) detected and masked
- [ ] Phone pattern (7-15 digits) detected and masked
- [ ] Test file passes all assertions
</success_criteria>

<output>
After completion, create `.planning/phases/09-data-privacy-hardening/09-02-SUMMARY.md`
</output>
